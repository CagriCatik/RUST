<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_Primitive_Data_Types/index.html"><strong aria-hidden="true">1.</strong> Primitive Data Types</a></li><li class="chapter-item expanded "><a href="02_Compound_Data_Types/index.html"><strong aria-hidden="true">2.</strong> Compound Data Types</a></li><li class="chapter-item expanded "><a href="03_Functions/index.html"><strong aria-hidden="true">3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="04_Ownership/index.html"><strong aria-hidden="true">4.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="05_Borrowing_and_References/index.html"><strong aria-hidden="true">5.</strong> Borrowing and References</a></li><li class="chapter-item expanded "><a href="06_Variables_&_Mutability/index.html"><strong aria-hidden="true">6.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="07_Constants/index.html"><strong aria-hidden="true">7.</strong> Constants</a></li><li class="chapter-item expanded "><a href="08_Shadowing/index.html"><strong aria-hidden="true">8.</strong> Shadowing</a></li><li class="chapter-item expanded "><a href="09_Comments/index.html"><strong aria-hidden="true">9.</strong> Comments</a></li><li class="chapter-item expanded "><a href="10_If_Else_Statements_Control_Flow/index.html"><strong aria-hidden="true">10.</strong> If-else Statements</a></li><li class="chapter-item expanded "><a href="11_Loops-Control-Flow/index.html"><strong aria-hidden="true">11.</strong> Loops</a></li><li class="chapter-item expanded "><a href="12_Structs/index.html"><strong aria-hidden="true">12.</strong> Structs</a></li><li class="chapter-item expanded "><a href="13_Enums/index.html"><strong aria-hidden="true">13.</strong> Enums</a></li><li class="chapter-item expanded "><a href="14_Error-Handling/index.html"><strong aria-hidden="true">14.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="15_Collection-Types/index.html"><strong aria-hidden="true">15.</strong> Collection Types</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="primitive-data-types"><a class="header" href="#primitive-data-types">Primitive Data Types</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>This tutorial will provide an in-depth explanation of primitive data types in the Rust programming language. Rust, a statically-typed language, requires the explicit declaration of data types for variables. Understanding these types is crucial for efficient memory management and ensuring code correctness. This lesson covers the fundamental primitive data types, including integers, floating-point numbers, Booleans, and characters.</p>
<h2 id="1-primitive-data-types-in-rust"><a class="header" href="#1-primitive-data-types-in-rust">1. Primitive Data Types in Rust</a></h2>
<p>Rust’s primitive data types, also known as scalar types, represent single values. These types are foundational to understanding how data is handled in Rust. The four primary scalar types in Rust are:</p>
<ol>
<li><strong>Integers</strong>: Signed (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>) and Unsigned (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>).</li>
<li><strong>Floating-point numbers</strong>: <code>f32</code> and <code>f64</code>.</li>
<li><strong>Boolean</strong>: <code>bool</code>.</li>
<li><strong>Character</strong>: <code>char</code>.</li>
</ol>
<h3 id="11-integer-types"><a class="header" href="#11-integer-types">1.1 Integer Types</a></h3>
<p>Rust offers both signed and unsigned integers, each with a range defined by their bit size.</p>
<ul>
<li>
<p><strong>Signed Integers (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>)</strong>: These integers can store both positive and negative numbers. The range of values depends on the bit size. For example:</p>
<ul>
<li><code>i8</code> ranges from -128 to 127.</li>
<li><code>i32</code> ranges from -2^31 to 2^31 - 1.</li>
</ul>
</li>
<li>
<p><strong>Unsigned Integers (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>)</strong>: These integers store only positive numbers and have a range starting from 0. For example:</p>
<ul>
<li><code>u8</code> ranges from 0 to 255.</li>
<li><code>u32</code> ranges from 0 to 2^32 - 1.</li>
</ul>
</li>
</ul>
<h4 id="example-integer-types"><a class="header" href="#example-integer-types">Example: Integer Types</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32 = -42; // Signed 32-bit integer
    let y: u64 = 100; // Unsigned 64-bit integer
    
    println!("Signed integer: {}", x);
    println!("Unsigned integer: {}", y);
}</code></pre></pre>
<h4 id="explanation"><a class="header" href="#explanation">Explanation</a></h4>
<ul>
<li>In this example, <code>x</code> is an <code>i32</code>, allowing it to hold both positive and negative values.</li>
<li><code>y</code> is a <code>u64</code>, meaning it can only hold positive values.</li>
</ul>
<h3 id="12-floating-point-types"><a class="header" href="#12-floating-point-types">1.2 Floating-Point Types</a></h3>
<p>Floating-point numbers in Rust represent real numbers with fractional parts. Rust supports two types:</p>
<ul>
<li><strong><code>f32</code></strong>: A 32-bit floating-point number.</li>
<li><strong><code>f64</code></strong>: A 64-bit floating-point number, which is the default type for floating-point literals in Rust.</li>
</ul>
<h4 id="example-floating-point-types"><a class="header" href="#example-floating-point-types">Example: Floating-Point Types</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pi: f64 = 3.14; // 64-bit floating-point number
    
    println!("Value of Pi: {}", pi);
}</code></pre></pre>
<h4 id="explanation-1"><a class="header" href="#explanation-1">Explanation</a></h4>
<ul>
<li>Here, <code>pi</code> is defined as an <code>f64</code>, which provides more precision compared to <code>f32</code>.</li>
</ul>
<h3 id="13-boolean-type"><a class="header" href="#13-boolean-type">1.3 Boolean Type</a></h3>
<p>The Boolean type in Rust is represented by the <code>bool</code> keyword. It can take only two values: <code>true</code> or <code>false</code>.</p>
<h4 id="example-boolean-type"><a class="header" href="#example-boolean-type">Example: Boolean Type</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let is_snowing: bool = true;
    
    println!("Is it snowing? {}", is_snowing);
}</code></pre></pre>
<h4 id="explanation-2"><a class="header" href="#explanation-2">Explanation</a></h4>
<ul>
<li>The variable <code>is_snowing</code> is of type <code>bool</code> and holds the value <code>true</code>.</li>
</ul>
<h3 id="14-character-type"><a class="header" href="#14-character-type">1.4 Character Type</a></h3>
<p>The <code>char</code> type in Rust represents a single Unicode scalar value. It can hold any character, including letters, numbers, and special symbols.</p>
<h4 id="example-character-type"><a class="header" href="#example-character-type">Example: Character Type</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let letter: char = 'A';
    
    println!("First letter of the alphabet: {}", letter);
}</code></pre></pre>
<h4 id="explanation-3"><a class="header" href="#explanation-3">Explanation</a></h4>
<ul>
<li>The variable <code>letter</code> is of type <code>char</code> and holds the value <code>'A'</code>. Rust’s <code>char</code> type is 4 bytes in size and can represent a wide range of characters beyond just ASCII.</li>
</ul>
<h2 id="2-common-errors-and-considerations"><a class="header" href="#2-common-errors-and-considerations">2. Common Errors and Considerations</a></h2>
<p>Understanding the size and range of each data type is crucial for avoiding common errors:</p>
<h3 id="21-integer-overflow"><a class="header" href="#21-integer-overflow">2.1 Integer Overflow</a></h3>
<p>If you try to assign a value outside the range of a type, Rust’s compiler will throw an error.</p>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32 = 2_147_483_648; // This exceeds the i32 range
}</code></pre></pre>
<h4 id="compiler-error"><a class="header" href="#compiler-error">Compiler Error</a></h4>
<pre><code>error: literal out of range for `i32`
</code></pre>
<h3 id="22-type-mismatch"><a class="header" href="#22-type-mismatch">2.2 Type Mismatch</a></h3>
<p>Rust enforces strict type checking. You cannot assign a negative value to an unsigned integer, nor can you mix types without explicit conversion.</p>
<h4 id="example-1"><a class="header" href="#example-1">Example</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y: u64 = -100; // Unsigned type cannot hold a negative value
}</code></pre></pre>
<h4 id="compiler-error-1"><a class="header" href="#compiler-error-1">Compiler Error</a></h4>
<pre><code>error: cannot apply unary operator `-` to type `u64`
</code></pre>
<h2 id="3-summary"><a class="header" href="#3-summary">3. Summary</a></h2>
<p>Rust’s primitive data types are essential for understanding how to efficiently manage memory and ensure code correctness. By mastering these types, developers can write more reliable and performant Rust code. This lesson covered:</p>
<ul>
<li><strong>Integer Types</strong>: Understanding signed and unsigned integers and their ranges.</li>
<li><strong>Floating-Point Types</strong>: Handling real numbers with fractional parts.</li>
<li><strong>Boolean Type</strong>: Using <code>bool</code> for logical operations.</li>
<li><strong>Character Type</strong>: Representing single Unicode scalar values with <code>char</code>.</li>
</ul>
<p>Further lessons will build on these concepts, delving into compound data types and more advanced Rust programming techniques.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compound-data-types"><a class="header" href="#compound-data-types">Compound Data Types</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>In this tutorial, we will delve into compound data types in the Rust programming language. Compound data types are more complex structures that can store multiple values within a single variable. Rust supports four primary compound data types: arrays, tuples, slices, and strings. Understanding these types is essential for managing collections of data efficiently and for taking advantage of Rust’s memory safety guarantees.</p>
<h2 id="1-compound-data-types-in-rust"><a class="header" href="#1-compound-data-types-in-rust">1. Compound Data Types in Rust</a></h2>
<h3 id="11-arrays"><a class="header" href="#11-arrays">1.1 Arrays</a></h3>
<p><strong>Arrays</strong> in Rust are fixed-size collections of elements that must all be of the same type, ensuring homogeneity. The size of an array is determined at compile time, and its elements are stored contiguously in memory.</p>
<h4 id="example-defining-an-array"><a class="header" href="#example-defining-an-array">Example: Defining an Array</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers: [i32; 5] = [1, 2, 3, 4, 5]; // An array of 5 integers
    
    println!("Number array: {:?}", numbers);
}</code></pre></pre>
<h4 id="explanation-4"><a class="header" href="#explanation-4">Explanation:</a></h4>
<ul>
<li><code>numbers</code> is an array of five 32-bit integers (<code>i32</code>).</li>
<li>Arrays are defined using square brackets. The syntax <code>[i32; 5]</code> specifies that the array contains <code>i32</code> elements and has a length of 5.</li>
<li>The <code>:?</code> inside the curly braces is a debug format specifier, which allows you to print the entire array.</li>
</ul>
<h5 id="common-error-mixed-data-types-in-arrays"><a class="header" href="#common-error-mixed-data-types-in-arrays">Common Error: Mixed Data Types in Arrays</a></h5>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mix = [1, "apple", true]; // Invalid: mixed types in array
}</code></pre></pre>
<h4 id="compiler-error-2"><a class="header" href="#compiler-error-2">Compiler Error:</a></h4>
<pre><code>error: expected integer, found `&amp;str`
</code></pre>
<h4 id="explanation-5"><a class="header" href="#explanation-5">Explanation:</a></h4>
<ul>
<li>Rust enforces that all elements in an array must be of the same type. The code above fails because it attempts to mix integers, strings, and booleans within a single array.</li>
</ul>
<h3 id="12-tuples"><a class="header" href="#12-tuples">1.2 Tuples</a></h3>
<p><strong>Tuples</strong> in Rust can hold multiple values of different types within a single variable. Unlike arrays, tuples can store heterogeneous data. Each element in a tuple can be of a different type, and tuples themselves are of a fixed size, determined at the time of their declaration.</p>
<h4 id="example-defining-a-tuple"><a class="header" href="#example-defining-a-tuple">Example: Defining a Tuple</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let human: (&amp;str, i32, bool) = ("Alice", 30, true); // A tuple with a string, an integer, and a boolean
    
    println!("Human tuple: {:?}", human);
}</code></pre></pre>
<h4 id="explanation-6"><a class="header" href="#explanation-6">Explanation:</a></h4>
<ul>
<li><code>human</code> is a tuple that stores a string slice (<code>&amp;str</code>), an integer (<code>i32</code>), and a boolean (<code>bool</code>).</li>
<li>The tuple elements are accessed by their index, starting from 0. The elements of a tuple are defined within parentheses <code>()</code>.</li>
</ul>
<h5 id="mixed-data-types-in-tuples"><a class="header" href="#mixed-data-types-in-tuples">Mixed Data Types in Tuples</a></h5>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_mix = ("Katos", 23, true, [1, 2, 3, 4, 5]); // A tuple with different data types, including an array
    
    println!("Mixed tuple: {:?}", my_mix);
}</code></pre></pre>
<h4 id="explanation-7"><a class="header" href="#explanation-7">Explanation:</a></h4>
<ul>
<li>Tuples can contain different types of data, including other compound data types such as arrays.</li>
</ul>
<h3 id="13-slices"><a class="header" href="#13-slices">1.3 Slices</a></h3>
<p><strong>Slices</strong> in Rust are dynamically sized views into a contiguous sequence of elements within a collection, such as an array. Slices do not own the data they reference, making them useful for borrowing a portion of a collection without copying it.</p>
<h4 id="example-defining-a-slice"><a class="header" href="#example-defining-a-slice">Example: Defining a Slice</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers: [i32; 5] = [1, 2, 3, 4, 5]; 
    let number_slice: &amp;[i32] = &amp;numbers[1..4]; // A slice of the array from index 1 to 3
    
    println!("Number slice: {:?}", number_slice);
}</code></pre></pre>
<h4 id="explanation-8"><a class="header" href="#explanation-8">Explanation:</a></h4>
<ul>
<li><code>number_slice</code> is a slice of the <code>numbers</code> array, containing the elements from index 1 to 3 (<code>[2, 3, 4]</code>).</li>
<li>The syntax <code>&amp;numbers[1..4]</code> creates a slice from the <code>numbers</code> array, including elements at indices 1, 2, and 3 (but not 4).</li>
</ul>
<h3 id="14-strings-and-string-slices"><a class="header" href="#14-strings-and-string-slices">1.4 Strings and String Slices</a></h3>
<p><strong>Strings</strong> in Rust are growable, mutable, and owned collections of UTF-8 encoded text. They are stored on the heap and can be modified dynamically. Rust also supports <strong>string slices</strong> (<code>&amp;str</code>), which are references to a part of a string or an entire string.</p>
<h4 id="example-string-and-string-slice"><a class="header" href="#example-string-and-string-slice">Example: String and String Slice</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut greeting: String = String::from("Hello"); // A mutable String
    greeting.push_str(", world!"); // Appending to the string
    
    println!("Greeting: {}", greeting);
    
    let slice: &amp;str = &amp;greeting[0..5]; // A slice of the string
    println!("Slice: {}", slice);
}</code></pre></pre>
<h4 id="explanation-9"><a class="header" href="#explanation-9">Explanation:</a></h4>
<ul>
<li><code>greeting</code> is a <code>String</code> object, initially containing <code>"Hello"</code>, and is then appended with <code>", world!"</code>.</li>
<li>The <code>slice</code> is a string slice that refers to the first five characters of <code>greeting</code> (<code>"Hello"</code>).</li>
<li>Strings are stored on the heap, allowing them to grow or shrink at runtime. In contrast, string slices are immutable references to a portion of a string, usually stored on the stack.</li>
</ul>
<h4 id="memory-allocation-and-management"><a class="header" href="#memory-allocation-and-management">Memory Allocation and Management</a></h4>
<p>Rust’s memory management is crucial for understanding how strings and slices operate:</p>
<ul>
<li><strong>Strings</strong> are heap-allocated, meaning they are dynamically sized and can be modified.</li>
<li><strong>String slices</strong> are references to a part of a string, which do not own the data they refer to. They are used for efficiently accessing parts of a string without copying or owning the data.</li>
</ul>
<h4 id="common-error-string-vs-string-slice"><a class="header" href="#common-error-string-vs-string-slice">Common Error: String vs. String Slice</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let hello = String::from("Hello");
    let slice = &amp;hello[0..5]; // Valid string slice
    
    println!("Slice value: {}", slice);
}</code></pre></pre>
<ul>
<li><strong>Strings</strong> can be mutable and are used when ownership of text data is required.</li>
<li><strong>String slices</strong> are used to borrow a section of a string without taking ownership, optimizing memory usage.</li>
</ul>
<h2 id="2-summary"><a class="header" href="#2-summary">2. Summary</a></h2>
<p>Compound data types in Rust are powerful tools for managing collections of data. This lesson covered:</p>
<ul>
<li><strong>Arrays</strong>: Fixed-size, homogeneous collections.</li>
<li><strong>Tuples</strong>: Heterogeneous, fixed-size collections.</li>
<li><strong>Slices</strong>: Dynamically-sized views into contiguous sequences.</li>
<li><strong>Strings</strong>: Mutable, growable text data stored on the heap.</li>
<li><strong>String Slices</strong>: Immutable references to parts of a string.</li>
</ul>
<p>These data structures are essential for writing efficient and memory-safe code in Rust. Understanding the differences between these types, especially with regard to memory allocation and mutability, is critical for developing robust Rust applications. In future lessons, we will explore more advanced topics, such as Rust’s ownership model, borrowing, and lifetimes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>In this lesson, we will explore functions in Rust, a fundamental aspect of the language that allows for code modularity, reusability, and clarity. Functions in Rust are defined using the <code>fn</code> keyword and are essential for organizing logic and operations within your programs. We will cover function syntax, parameter passing, return values, and the distinction between expressions and statements.</p>
<h2 id="1-introduction-to-functions-in-rust"><a class="header" href="#1-introduction-to-functions-in-rust">1. Introduction to Functions in Rust</a></h2>
<h3 id="11-the-main-function"><a class="header" href="#11-the-main-function">1.1 The <code>main</code> Function</a></h3>
<p>Every Rust program starts execution from the <code>main</code> function, which serves as the entry point. This function must be named <code>main</code> and is required in all executable Rust projects. Renaming or omitting this function will result in compilation errors, as Rust will not know where to begin execution.</p>
<h4 id="example-basic-main-function"><a class="header" href="#example-basic-main-function">Example: Basic <code>main</code> Function</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<h4 id="explanation-10"><a class="header" href="#explanation-10">Explanation</a></h4>
<ul>
<li>The <code>main</code> function in this example prints "Hello, world!" to the console. This function is automatically recognized and executed by the Rust compiler when you run your program.</li>
</ul>
<h3 id="12-defining-functions"><a class="header" href="#12-defining-functions">1.2 Defining Functions</a></h3>
<p>Functions in Rust are defined using the <code>fn</code> keyword followed by the function name, parameter list (if any), and the function body enclosed in curly braces. Function names should be written in snake_case, where all letters are lowercase and words are separated by underscores.</p>
<h4 id="example-defining-a-function"><a class="header" href="#example-defining-a-function">Example: Defining a Function</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello_rust() {
    println!("Hello, Rust!");
}
<span class="boring">}</span></code></pre></pre>
<h4 id="explanation-11"><a class="header" href="#explanation-11">Explanation</a></h4>
<ul>
<li>The function <code>hello_rust</code> prints "Hello, Rust!" when called. It follows Rust's naming convention of snake_case for function names.</li>
</ul>
<h3 id="13-calling-functions"><a class="header" href="#13-calling-functions">1.3 Calling Functions</a></h3>
<p>Once a function is defined, it can be called from anywhere within the scope where it is visible. Functions can be called before or after their definition, thanks to Rust’s feature of function hoisting, which allows functions to be defined in any order within the same scope.</p>
<h4 id="example-calling-a-function"><a class="header" href="#example-calling-a-function">Example: Calling a Function</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    hello_rust();
}

fn hello_rust() {
    println!("Hello, Rust!");
}</code></pre></pre>
<h4 id="explanation-12"><a class="header" href="#explanation-12">Explanation</a></h4>
<ul>
<li>The <code>hello_rust</code> function is called from the <code>main</code> function. Even though <code>hello_rust</code> is defined after the <code>main</code> function, Rust allows it due to hoisting.</li>
</ul>
<h2 id="2-function-parameters-and-return-values"><a class="header" href="#2-function-parameters-and-return-values">2. Function Parameters and Return Values</a></h2>
<h3 id="21-function-parameters"><a class="header" href="#21-function-parameters">2.1 Function Parameters</a></h3>
<p>Functions in Rust can accept parameters, which are values passed to the function when it is called. Parameters are specified within the parentheses following the function name, along with their data types. Multiple parameters are separated by commas.</p>
<h4 id="example-function-with-parameters"><a class="header" href="#example-function-with-parameters">Example: Function with Parameters</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn tell_height(height: i32) {
    println!("My height is {} cm.", height);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="explanation-13"><a class="header" href="#explanation-13">Explanation</a></h4>
<ul>
<li>The <code>tell_height</code> function takes an <code>i32</code> parameter named <code>height</code> and prints it as part of a formatted string.</li>
</ul>
<h3 id="22-function-return-values"><a class="header" href="#22-function-return-values">2.2 Function Return Values</a></h3>
<p>Functions in Rust can also return values. The return type is specified after an arrow <code>-&gt;</code> following the parameter list. The return value is usually the result of an expression within the function.</p>
<h4 id="example-function-returning-a-value"><a class="header" href="#example-function-returning-a-value">Example: Function Returning a Value</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<h4 id="explanation-14"><a class="header" href="#explanation-14">Explanation</a></h4>
<ul>
<li>The <code>add</code> function takes two <code>i32</code> parameters, <code>a</code> and <code>b</code>, and returns their sum. Notice that the final expression <code>a + b</code> does not end with a semicolon, indicating that it is the return value of the function.</li>
</ul>
<h3 id="23-expressions-vs-statements"><a class="header" href="#23-expressions-vs-statements">2.3 Expressions vs. Statements</a></h3>
<p>In Rust, an <strong>expression</strong> is anything that returns a value, while a <strong>statement</strong> is a command that performs an action but does not return a value. Understanding the difference is crucial for writing correct and idiomatic Rust code.</p>
<h4 id="example-expression-and-statement"><a class="header" href="#example-expression-and-statement">Example: Expression and Statement</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = {
        let price = 5;
        let quantity = 10;
        price * quantity
    };
    println!("Result: {}", x);
}</code></pre></pre>
<h4 id="explanation-15"><a class="header" href="#explanation-15">Explanation</a></h4>
<ul>
<li>The block <code>{ let price = 5; let quantity = 10; price * quantity }</code> is an expression that evaluates to <code>50</code>. The result is assigned to <code>x</code>.</li>
<li>A statement would be <code>let price = 5;</code>, which does not return a value but performs an action (declaring a variable).</li>
</ul>
<h2 id="3-advanced-function-features"><a class="header" href="#3-advanced-function-features">3. Advanced Function Features</a></h2>
<h3 id="31-function-with-multiple-parameters-and-return-value"><a class="header" href="#31-function-with-multiple-parameters-and-return-value">3.1 Function with Multiple Parameters and Return Value</a></h3>
<p>Rust functions can take multiple parameters of different types and return a value. This allows for more complex operations within a single function.</p>
<h4 id="example-function-with-multiple-parameters"><a class="header" href="#example-function-with-multiple-parameters">Example: Function with Multiple Parameters</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn human_id(name: &amp;str, age: u32, height: f32) {
    println!("My name is {}, I am {} years old, and my height is {} cm.", name, age, height);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="explanation-16"><a class="header" href="#explanation-16">Explanation</a></h4>
<ul>
<li>The <code>human_id</code> function takes three parameters: <code>name</code> (a string slice), <code>age</code> (an unsigned 32-bit integer), and <code>height</code> (a 32-bit floating point number). It prints these values in a formatted string.</li>
</ul>
<h3 id="32-returning-values-from-functions"><a class="header" href="#32-returning-values-from-functions">3.2 Returning Values from Functions</a></h3>
<p>Functions in Rust can perform operations and return the result. For example, you might want to create a function that calculates the Body Mass Index (BMI).</p>
<h4 id="example-calculating-bmi"><a class="header" href="#example-calculating-bmi">Example: Calculating BMI</a></h4>
<pre><pre class="playground"><code class="language-rust">fn calculate_bmi(weight_kg: f64, height_m: f64) -&gt; f64 {
    weight_kg / (height_m * height_m)
}

fn main() {
    let bmi = calculate_bmi(70.0, 1.75);
    println!("Your BMI is {:.2}", bmi);
}</code></pre></pre>
<h4 id="explanation-17"><a class="header" href="#explanation-17">Explanation</a></h4>
<ul>
<li>The <code>calculate_bmi</code> function takes weight and height as parameters, computes the BMI, and returns the result. The result is printed with two decimal places.</li>
</ul>
<h2 id="4-summary"><a class="header" href="#4-summary">4. Summary</a></h2>
<p>Functions are a critical component in Rust, allowing for modular, reusable code. This lesson covered:</p>
<ul>
<li>The basic structure of functions in Rust.</li>
<li>How to define and call functions.</li>
<li>The use of parameters and return values.</li>
<li>The distinction between expressions and statements.</li>
<li>Advanced features like functions with multiple parameters and return values.</li>
</ul>
<p>By mastering these concepts, you can write more organized and efficient Rust programs. Subsequent lessons will explore more advanced topics such as error handling, lifetimes, and ownership in Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>In this lesson, we will explore one of the most critical concepts in Rust: Ownership. Rust's ownership model is a unique feature that ensures memory safety without needing a garbage collector, making it stand out among other programming languages. Understanding ownership is fundamental to mastering Rust, as it governs how memory is managed in your programs, ensuring that your applications are both safe and efficient.</p>
<h2 id="1-why-ownership-matters"><a class="header" href="#1-why-ownership-matters">1. Why Ownership Matters</a></h2>
<h3 id="11-memory-management-in-traditional-languages"><a class="header" href="#11-memory-management-in-traditional-languages">1.1 Memory Management in Traditional Languages</a></h3>
<p>In traditional programming languages like C and C++, memory management is manual. Developers must explicitly allocate and deallocate memory, which can lead to issues such as:</p>
<ul>
<li><strong>Double freeing</strong>: Releasing the same memory more than once.</li>
<li><strong>Memory leaks</strong>: Forgetting to free memory, leading to wasted resources.</li>
</ul>
<h3 id="12-garbage-collection"><a class="header" href="#12-garbage-collection">1.2 Garbage Collection</a></h3>
<p>Some languages, like Java and Python, use a garbage collector to automate memory management. The garbage collector tracks and frees memory that is no longer in use. However, this can introduce performance drawbacks, such as pauses in program execution when the garbage collector runs, leading to inefficiencies, especially in performance-critical applications.</p>
<h3 id="13-rusts-solution-ownership"><a class="header" href="#13-rusts-solution-ownership">1.3 Rust’s Solution: Ownership</a></h3>
<p>Rust introduces the concept of <strong>ownership</strong> to manage memory efficiently and safely. Ownership enforces strict rules at compile time, ensuring that memory is used correctly and preventing common bugs related to memory management. Rust's ownership model is designed to eliminate the need for a garbage collector, resulting in faster and more predictable performance.</p>
<h2 id="2-the-three-rules-of-ownership"><a class="header" href="#2-the-three-rules-of-ownership">2. The Three Rules of Ownership</a></h2>
<p>Rust's ownership system is built on three fundamental rules:</p>
<ol>
<li><strong>Each value in Rust has a single owner.</strong></li>
<li><strong>There can only be one owner at a time.</strong></li>
<li><strong>When the owner goes out of scope, the value will be dropped.</strong></li>
</ol>
<h3 id="21-rule-1-each-value-has-an-owner"><a class="header" href="#21-rule-1-each-value-has-an-owner">2.1 Rule 1: Each Value Has an Owner</a></h3>
<p>Every value in Rust is owned by a variable. This means that each piece of data in your program is associated with a specific owner, which is a variable that controls the data.</p>
<h4 id="example-value-ownership"><a class="header" href="#example-value-ownership">Example: Value Ownership</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("Rust");
    // s1 owns the string "Rust"
}</code></pre></pre>
<h4 id="explanation-18"><a class="header" href="#explanation-18">Explanation</a></h4>
<ul>
<li>In this example, the variable <code>s1</code> owns the <code>String</code> value <code>"Rust"</code>. The ownership means that <code>s1</code> is responsible for managing the memory that the string occupies.</li>
</ul>
<h3 id="22-rule-2-only-one-owner-at-a-time"><a class="header" href="#22-rule-2-only-one-owner-at-a-time">2.2 Rule 2: Only One Owner at a Time</a></h3>
<p>Ownership in Rust is exclusive. When ownership is transferred from one variable to another, the original owner can no longer access the value.</p>
<h4 id="example-ownership-transfer"><a class="header" href="#example-ownership-transfer">Example: Ownership Transfer</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("Rust");
    let s2 = s1; // Ownership transferred from s1 to s2
    
    // println!("{}", s1); // Error: s1 no longer owns the value
    println!("{}", s2); // This works, as s2 is the current owner
}</code></pre></pre>
<h4 id="explanation-19"><a class="header" href="#explanation-19">Explanation</a></h4>
<ul>
<li>When <code>s2</code> is assigned the value of <code>s1</code>, ownership is transferred to <code>s2</code>. After the transfer, <code>s1</code> is no longer valid, and any attempt to use <code>s1</code> will result in a compilation error.</li>
</ul>
<h3 id="23-rule-3-value-dropped-when-owner-goes-out-of-scope"><a class="header" href="#23-rule-3-value-dropped-when-owner-goes-out-of-scope">2.3 Rule 3: Value Dropped When Owner Goes Out of Scope</a></h3>
<p>When a variable goes out of scope, Rust automatically drops (deallocates) the value it owns, freeing the associated memory.</p>
<h4 id="example-dropping-values"><a class="header" href="#example-dropping-values">Example: Dropping Values</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let s1 = String::from("Rust");
        // s1 is valid within this block
    }
    // s1 is dropped here, and its memory is freed
}</code></pre></pre>
<h4 id="explanation-20"><a class="header" href="#explanation-20">Explanation</a></h4>
<ul>
<li>The variable <code>s1</code> is only valid within its scope (the inner block). Once the block ends, <code>s1</code> goes out of scope, and Rust automatically drops the value, freeing the memory.</li>
</ul>
<h2 id="3-borrowing-and-references"><a class="header" href="#3-borrowing-and-references">3. Borrowing and References</a></h2>
<p>Ownership can be temporarily transferred or shared through <strong>borrowing</strong> and <strong>references</strong>. Borrowing allows a function or another part of the code to temporarily use a value without taking ownership.</p>
<h3 id="31-borrowing-with-references"><a class="header" href="#31-borrowing-with-references">3.1 Borrowing with References</a></h3>
<p>A reference allows you to access a value without taking ownership. This enables multiple parts of your code to read from the same data without violating the ownership rules.</p>
<h4 id="example-borrowing-with-references"><a class="header" href="#example-borrowing-with-references">Example: Borrowing with References</a></h4>
<pre><pre class="playground"><code class="language-rust">fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}

fn main() {
    let s1 = String::from("Rust");
    let len = calculate_length(&amp;s1); // Borrowing s1
    
    println!("The length of '{}' is {}.", s1, len);
}</code></pre></pre>
<h4 id="explanation-21"><a class="header" href="#explanation-21">Explanation</a></h4>
<ul>
<li>The function <code>calculate_length</code> borrows the string <code>s1</code> by taking a reference (<code>&amp;String</code>). The ownership of <code>s1</code> remains with <code>main</code>, and <code>calculate_length</code> can read the data without owning it.</li>
<li>The reference (<code>&amp;s1</code>) allows <code>calculate_length</code> to access the string without transferring ownership, ensuring that <code>s1</code> remains valid in <code>main</code> after the function call.</li>
</ul>
<h3 id="32-mutable-references"><a class="header" href="#32-mutable-references">3.2 Mutable References</a></h3>
<p>Rust allows mutable references, enabling you to modify the borrowed value. However, Rust enforces that you can only have one mutable reference to a value at a time, preventing data races.</p>
<h4 id="example-mutable-references"><a class="header" href="#example-mutable-references">Example: Mutable References</a></h4>
<pre><pre class="playground"><code class="language-rust">fn change(s: &amp;mut String) {
    s.push_str(" is great!");
}

fn main() {
    let mut s1 = String::from("Rust");
    change(&amp;mut s1); // Borrowing s1 mutably
    
    println!("{}", s1);
}</code></pre></pre>
<h4 id="explanation-22"><a class="header" href="#explanation-22">Explanation</a></h4>
<ul>
<li>The <code>change</code> function borrows <code>s1</code> as a mutable reference (<code>&amp;mut String</code>), allowing it to modify the original string.</li>
<li>The <code>main</code> function passes a mutable reference to <code>change</code>, which then modifies the string by appending <code>" is great!"</code>.</li>
</ul>
<h2 id="4-summary-1"><a class="header" href="#4-summary-1">4. Summary</a></h2>
<p>Rust's ownership model is a powerful system that ensures memory safety without the need for a garbage collector. This lesson covered:</p>
<ul>
<li><strong>The Concept of Ownership</strong>: How Rust manages memory through strict ownership rules.</li>
<li><strong>The Three Rules of Ownership</strong>: Understanding that each value has one owner, there can be only one owner at a time, and values are dropped when their owner goes out of scope.</li>
<li><strong>Borrowing and References</strong>: How Rust allows you to use values temporarily without taking ownership, ensuring safety and preventing common memory errors.</li>
</ul>
<p>Understanding ownership is crucial to writing efficient and safe Rust code. It is the foundation of Rust’s memory safety guarantees and enables you to develop applications that are both fast and free of memory-related bugs. The next lesson will build on these concepts by exploring borrowing and references in greater depth, including mutable references and the rules around their usage.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing--references"><a class="header" href="#borrowing--references">Borrowing &amp; References</a></h1>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>In this lesson, we will explore borrowing and references in Rust, key concepts that allow for efficient memory management while ensuring safety. Building on the previous lesson about ownership, we'll see how Rust enforces rules that prevent common programming errors such as null pointer dereferencing and data races, which are prevalent in languages like C and C++. Understanding borrowing and references is essential to writing safe and concurrent Rust code.</p>
<h2 id="1-understanding-borrowing-and-references"><a class="header" href="#1-understanding-borrowing-and-references">1. Understanding Borrowing and References</a></h2>
<h3 id="11-what-is-borrowing"><a class="header" href="#11-what-is-borrowing">1.1 What is Borrowing?</a></h3>
<p>Borrowing in Rust allows you to access a value without taking ownership of it. Instead of transferring ownership, you can "borrow" the value temporarily, which enables you to use it in another part of your program without violating Rust's ownership rules.</p>
<h3 id="12-why-is-safety-important"><a class="header" href="#12-why-is-safety-important">1.2 Why is Safety Important?</a></h3>
<p>Safety in Rust refers to preventing common programming errors like:</p>
<ul>
<li><strong>Null pointer dereferencing</strong>: Accessing memory that hasn’t been properly initialized.</li>
<li><strong>Dangling pointers</strong>: References to memory that has already been freed.</li>
<li><strong>Buffer overflows</strong>: Writing data beyond the bounds of allocated memory.</li>
<li><strong>Data races</strong>: Concurrent access to memory that leads to unpredictable behavior.</li>
</ul>
<p>Rust's borrowing system, combined with its strict ownership model, ensures that these issues are avoided at compile time, making Rust programs both safe and efficient.</p>
<h2 id="2-creating-references-in-rust"><a class="header" href="#2-creating-references-in-rust">2. Creating References in Rust</a></h2>
<h3 id="21-immutable-references"><a class="header" href="#21-immutable-references">2.1 Immutable References</a></h3>
<p>An immutable reference allows you to read data without modifying it. When you create an immutable reference, you borrow the value without taking ownership, ensuring that the original data remains unchanged.</p>
<h4 id="example-immutable-reference"><a class="header" href="#example-immutable-reference">Example: Immutable Reference</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5; // `x` owns the value 5
    let r = &amp;x; // Immutable reference to `x`
    
    println!("Value of x is: {}", x);
    println!("Value of r is: {}", r);
}</code></pre></pre>
<h4 id="explanation-23"><a class="header" href="#explanation-23">Explanation:</a></h4>
<ul>
<li><code>x</code> owns the value <code>5</code>.</li>
<li><code>r</code> is an immutable reference to <code>x</code>, meaning it borrows <code>x</code> but does not own it. Both <code>x</code> and <code>r</code> can be used to access the value <code>5</code>, but neither can modify it.</li>
</ul>
<h3 id="22-mutable-references"><a class="header" href="#22-mutable-references">2.2 Mutable References</a></h3>
<p>A mutable reference allows you to both read and modify the data. However, Rust enforces that you can only have one mutable reference to a value at a time, preventing data races and ensuring memory safety.</p>
<h4 id="example-mutable-reference"><a class="header" href="#example-mutable-reference">Example: Mutable Reference</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5; // `x` is mutable
    let r = &amp;mut x; // Mutable reference to `x`
    
    *r += 1; // Modify the value via the reference
    println!("Value of x is: {}", x);
}</code></pre></pre>
<h4 id="explanation-24"><a class="header" href="#explanation-24">Explanation:</a></h4>
<ul>
<li><code>x</code> is declared mutable with <code>mut</code>.</li>
<li><code>r</code> is a mutable reference to <code>x</code>, allowing modification of <code>x</code> through <code>r</code>.</li>
<li>The value of <code>x</code> is incremented via the mutable reference <code>r</code>.</li>
</ul>
<h2 id="3-rules-for-borrowing"><a class="header" href="#3-rules-for-borrowing">3. Rules for Borrowing</a></h2>
<p>Rust enforces strict rules around borrowing to ensure safety and prevent undefined behavior.</p>
<h3 id="31-rule-1-only-one-mutable-reference-or-many-immutable-references"><a class="header" href="#31-rule-1-only-one-mutable-reference-or-many-immutable-references">3.1 Rule 1: Only One Mutable Reference or Many Immutable References</a></h3>
<p>You can have multiple immutable references to a value, but you cannot have a mutable reference if there are any immutable references. This rule prevents data races by ensuring that data cannot be read and modified simultaneously.</p>
<h4 id="example-conflict-between-immutable-and-mutable-references"><a class="header" href="#example-conflict-between-immutable-and-mutable-references">Example: Conflict Between Immutable and Mutable References</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    let r1 = &amp;x; // Immutable reference
    let r2 = &amp;x; // Another immutable reference
    
    // let r3 = &amp;mut x; // ERROR: Cannot borrow `x` as mutable because it is already borrowed as immutable
    
    println!("r1: {}, r2: {}", r1, r2);
}</code></pre></pre>
<h4 id="explanation-25"><a class="header" href="#explanation-25">Explanation:</a></h4>
<ul>
<li><code>r1</code> and <code>r2</code> are immutable references to <code>x</code>. Attempting to create <code>r3</code>, a mutable reference, would result in a compilation error because Rust does not allow both mutable and immutable references to coexist.</li>
</ul>
<h3 id="32-rule-2-references-must-always-be-valid"><a class="header" href="#32-rule-2-references-must-always-be-valid">3.2 Rule 2: References Must Always Be Valid</a></h3>
<p>Rust guarantees that references are always valid by preventing them from outliving the data they reference. When a value goes out of scope, any references to it are invalidated, preventing dangling references.</p>
<h4 id="example-scope-and-references"><a class="header" href="#example-scope-and-references">Example: Scope and References</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let r;
    {
        let x = 5;
        r = &amp;x;
    } // `x` goes out of scope here, `r` is now invalid
    
    // println!("r: {}", r); // ERROR: `x` does not live long enough
}</code></pre></pre>
<h4 id="explanation-26"><a class="header" href="#explanation-26">Explanation:</a></h4>
<ul>
<li>In this example, <code>x</code> goes out of scope at the end of the inner block. Since <code>r</code> is a reference to <code>x</code>, it becomes invalid when <code>x</code> is dropped, and Rust prevents you from using <code>r</code> outside of <code>x</code>'s scope.</li>
</ul>
<h2 id="4-practical-application-bank-account-example"><a class="header" href="#4-practical-application-bank-account-example">4. Practical Application: Bank Account Example</a></h2>
<p>To demonstrate borrowing and references in a practical scenario, let’s consider a struct representing a bank account. We will implement methods to manage the account balance while ensuring safe access through borrowing rules.</p>
<h3 id="41-struct-definition"><a class="header" href="#41-struct-definition">4.1 Struct Definition</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BankAccount {
    owner: String,
    balance: f64,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="42-implementing-methods-with-borrowing"><a class="header" href="#42-implementing-methods-with-borrowing">4.2 Implementing Methods with Borrowing</a></h3>
<p>We will create two methods: one for withdrawing money, which requires mutable access, and one for checking the balance, which requires immutable access.</p>
<h4 id="example-borrowing-in-methods"><a class="header" href="#example-borrowing-in-methods">Example: Borrowing in Methods</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl BankAccount {
    fn withdraw(&amp;mut self, amount: f64) {
        println!("Withdrawing {} from {}'s account", amount, self.owner);
        self.balance -= amount;
    }
    
    fn check_balance(&amp;self) {
        println!("Account owned by {} has a balance of {}.", self.owner, self.balance);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="explanation-27"><a class="header" href="#explanation-27">Explanation:</a></h4>
<ul>
<li><code>withdraw</code> takes a mutable reference to <code>self</code>, allowing it to modify the account balance.</li>
<li><code>check_balance</code> takes an immutable reference to <code>self</code>, ensuring that the balance is only read, not modified.</li>
</ul>
<h3 id="43-usage-in-main"><a class="header" href="#43-usage-in-main">4.3 Usage in <code>main</code></a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut account = BankAccount {
        owner: String::from("Alice"),
        balance: 1050.55,
    };
    
    account.check_balance(); // Immutable borrow
    account.withdraw(50.0);  // Mutable borrow
    account.check_balance(); // Immutable borrow again
}</code></pre></pre>
<h4 id="explanation-28"><a class="header" href="#explanation-28">Explanation:</a></h4>
<ul>
<li>The <code>main</code> function first creates an account and then checks the balance using an immutable borrow.</li>
<li>The <code>withdraw</code> method is called with a mutable borrow to update the balance.</li>
<li>Finally, the balance is checked again using another immutable borrow.</li>
<li>These operations are safe and compile without errors because the borrowing rules are followed correctly.</li>
</ul>
<h2 id="5-summary"><a class="header" href="#5-summary">5. Summary</a></h2>
<p>In this lesson, we covered the fundamental concepts of borrowing and references in Rust. Key points include:</p>
<ul>
<li><strong>Immutable References</strong>: Allow you to read data without modifying it.</li>
<li><strong>Mutable References</strong>: Allow you to modify data, but only one mutable reference can exist at a time.</li>
<li><strong>Borrowing Rules</strong>: Ensure safety by preventing simultaneous mutable and immutable references, and by ensuring that references are always valid.</li>
</ul>
<p>Understanding and applying these concepts is crucial for writing safe and efficient Rust code. Borrowing and references are integral to Rust's ability to provide memory safety guarantees without sacrificing performance. The next lesson will explore more advanced topics related to lifetimes and how Rust ensures that references always remain valid within the appropriate scope.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables--mutability"><a class="header" href="#variables--mutability">Variables &amp; Mutability</a></h1>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>In this lesson, we will delve into the concepts of variables and mutability in Rust. Understanding how variables work and how mutability is handled is fundamental to programming in Rust. Unlike many other languages, Rust variables are <strong>immutable by default</strong>, meaning once a variable is assigned a value, it cannot be changed unless explicitly made mutable. This default immutability is a key feature of Rust’s design, promoting safety and concurrency by preventing accidental modifications to data.</p>
<h2 id="1-variables-in-rust"><a class="header" href="#1-variables-in-rust">1. Variables in Rust</a></h2>
<h3 id="11-immutability-by-default"><a class="header" href="#11-immutability-by-default">1.1 Immutability by Default</a></h3>
<p>In Rust, variables are immutable by default. This means that once a value is assigned to a variable, that value cannot be changed. Immutability helps prevent bugs that arise from unintended changes to data and supports safe concurrency by ensuring that data does not change unexpectedly.</p>
<h4 id="example-immutable-variable"><a class="header" href="#example-immutable-variable">Example: Immutable Variable</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a: u16 = 5; // Declaring an immutable variable `a` with type u16 and value 5
    
    println!("The value of a is: {}", a);
    
    // Attempting to change the value of `a` will result in a compile-time error
    // a = 10; // ERROR: Cannot assign twice to immutable variable
}</code></pre></pre>
<h4 id="explanation-29"><a class="header" href="#explanation-29">Explanation:</a></h4>
<ul>
<li>The variable <code>a</code> is declared as immutable with the <code>let</code> keyword. Its type is <code>u16</code>, which is an unsigned 16-bit integer, and it is initialized with the value <code>5</code>.</li>
<li>The attempt to reassign <code>a</code> to <code>10</code> will result in a compilation error because <code>a</code> is immutable.</li>
</ul>
<h3 id="12-mutability-in-rust"><a class="header" href="#12-mutability-in-rust">1.2 Mutability in Rust</a></h3>
<p>To allow a variable to be modified after its initial assignment, you must explicitly declare it as mutable using the <code>mut</code> keyword. This signals to Rust that the variable can change, which is useful in scenarios where you need to update the value of a variable as the program executes.</p>
<h4 id="example-mutable-variable"><a class="header" href="#example-mutable-variable">Example: Mutable Variable</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut a: u16 = 5; // Declaring a mutable variable `a`
    
    println!("The initial value of a is: {}", a);
    
    a = 10; // Reassigning a new value to `a`
    
    println!("The new value of a is: {}", a);
}</code></pre></pre>
<h4 id="explanation-30"><a class="header" href="#explanation-30">Explanation:</a></h4>
<ul>
<li>By adding the <code>mut</code> keyword, the variable <code>a</code> is made mutable, allowing its value to be changed after its initial assignment.</li>
<li><code>a</code> is first assigned the value <code>5</code>, then reassigned to <code>10</code>. Both assignments are valid, and the program will compile and run without errors.</li>
</ul>
<h2 id="2-type-annotations-and-inference"><a class="header" href="#2-type-annotations-and-inference">2. Type Annotations and Inference</a></h2>
<p>Rust supports type annotations, where you explicitly specify the type of a variable. However, Rust also has strong type inference, which means it can often determine the type of a variable based on the value you assign to it.</p>
<h3 id="21-type-annotations"><a class="header" href="#21-type-annotations">2.1 Type Annotations</a></h3>
<p>You can explicitly specify the type of a variable when declaring it. This is useful for clarity or when Rust cannot infer the type.</p>
<h4 id="example-type-annotations"><a class="header" href="#example-type-annotations">Example: Type Annotations</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a: u16 = 5; // Type annotation specifying that `a` is a u16
    let b: f64 = 3.14; // Type annotation specifying that `b` is a 64-bit floating point
}</code></pre></pre>
<h3 id="22-type-inference"><a class="header" href="#22-type-inference">2.2 Type Inference</a></h3>
<p>Rust’s type inference system is powerful, allowing you to omit the type in many cases. Rust will automatically infer the type based on the assigned value.</p>
<h4 id="example-type-inference"><a class="header" href="#example-type-inference">Example: Type Inference</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = 5; // Rust infers `a` as an i32 by default
    let b = 3.14; // Rust infers `b` as an f64 by default
}</code></pre></pre>
<h4 id="explanation-31"><a class="header" href="#explanation-31">Explanation:</a></h4>
<ul>
<li>In the absence of an explicit type, Rust infers that <code>a</code> is an <code>i32</code> (the default integer type) and <code>b</code> is an <code>f64</code> (the default floating-point type).</li>
</ul>
<h2 id="3-common-errors-and-fixes"><a class="header" href="#3-common-errors-and-fixes">3. Common Errors and Fixes</a></h2>
<h3 id="31-immutable-variable-reassignment"><a class="header" href="#31-immutable-variable-reassignment">3.1 Immutable Variable Reassignment</a></h3>
<p>Attempting to reassign a value to an immutable variable will result in a compilation error. Rust’s error messages are informative and often suggest solutions, such as making the variable mutable.</p>
<h4 id="example-compilation-error"><a class="header" href="#example-compilation-error">Example: Compilation Error</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = 5;
    a = 10; // ERROR: Cannot assign twice to immutable variable `a`
}</code></pre></pre>
<h4 id="fix"><a class="header" href="#fix">Fix:</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut a = 5; // Fix by making `a` mutable
    a = 10;
}</code></pre></pre>
<h3 id="32-unused-variables"><a class="header" href="#32-unused-variables">3.2 Unused Variables</a></h3>
<p>Rust warns you if you declare a variable but do not use it. This is to help you avoid having unused code that could indicate a logical error in your program.</p>
<h4 id="example-unused-variable-warning"><a class="header" href="#example-unused-variable-warning">Example: Unused Variable Warning</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = 5; // Warning: unused variable `a`
}</code></pre></pre>
<h4 id="fix-1"><a class="header" href="#fix-1">Fix:</a></h4>
<ul>
<li>To suppress the warning, you can either use the variable or prefix the variable name with an underscore (<code>_</code>).</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _a = 5; // No warning since `_a` is intentionally unused
}</code></pre></pre>
<h2 id="4-summary-2"><a class="header" href="#4-summary-2">4. Summary</a></h2>
<p>In this lesson, we explored variables and mutability in Rust. Key points include:</p>
<ul>
<li><strong>Immutability by Default</strong>: Variables in Rust are immutable unless explicitly marked as mutable with the <code>mut</code> keyword.</li>
<li><strong>Mutability</strong>: Mutable variables can be reassigned, allowing for changes to their value after initial assignment.</li>
<li><strong>Type Annotations and Inference</strong>: Rust can infer types based on assigned values, but you can also explicitly specify types for clarity or when necessary.</li>
<li><strong>Common Errors</strong>: Rust’s compiler provides helpful error messages and suggestions to fix issues related to immutability and unused variables.</li>
</ul>
<p>Understanding these concepts is crucial for writing safe, efficient, and idiomatic Rust code. In the next lesson, we will explore constants in Rust, which differ from variables in important ways, particularly regarding mutability and scope.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>In this lesson, we will explore constants in Rust, which are distinct from variables and play a crucial role in defining fixed values that cannot be changed during the execution of a program. Constants, like immutable variables, are bound to a name and remain unchanged. However, constants have specific characteristics and rules that differentiate them from variables. Understanding these differences is essential for writing clear and efficient Rust code.</p>
<h2 id="1-introduction-to-constants-in-rust"><a class="header" href="#1-introduction-to-constants-in-rust">1. Introduction to Constants in Rust</a></h2>
<h3 id="11-what-is-a-constant"><a class="header" href="#11-what-is-a-constant">1.1 What is a Constant?</a></h3>
<p>A constant in Rust is a value that is bound to a name and is immutable, meaning it cannot be changed after its declaration. Constants are particularly useful for values that should remain consistent throughout the execution of a program, such as mathematical constants or configuration parameters.</p>
<h3 id="12-differences-between-constants-and-variables"><a class="header" href="#12-differences-between-constants-and-variables">1.2 Differences Between Constants and Variables</a></h3>
<p>Although both constants and variables can be immutable, there are key differences between them:</p>
<ul>
<li><strong>Constants cannot be made mutable</strong>: Unlike variables, you cannot use the <code>mut</code> keyword with constants. They are always immutable by default.</li>
<li><strong>Type annotation is required</strong>: When declaring a constant, you must specify its type explicitly.</li>
<li><strong>Constants are evaluated at compile time</strong>: The value of a constant must be a constant expression that the compiler can evaluate.</li>
<li><strong>Scope</strong>: Constants can be declared in any scope, including global scope, making them accessible throughout your program.</li>
</ul>
<h2 id="2-declaring-constants-in-rust"><a class="header" href="#2-declaring-constants-in-rust">2. Declaring Constants in Rust</a></h2>
<h3 id="21-syntax-for-constants"><a class="header" href="#21-syntax-for-constants">2.1 Syntax for Constants</a></h3>
<p>Constants in Rust are declared using the <code>const</code> keyword, followed by the name of the constant, the type annotation, and the value. The name of a constant should be written in uppercase with underscores separating words, adhering to Rust's naming conventions.</p>
<h4 id="example-declaring-a-constant"><a class="header" href="#example-declaring-a-constant">Example: Declaring a Constant</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    const Y: i32 = 10; // Declaring a constant `Y` with type i32 and value 10
    
    println!("The value of Y is: {}", Y);
}</code></pre></pre>
<h4 id="explanation-32"><a class="header" href="#explanation-32">Explanation</a></h4>
<ul>
<li><code>const Y: i32 = 10;</code> declares a constant <code>Y</code> of type <code>i32</code> with a value of <code>10</code>.</li>
<li>The constant <code>Y</code> is used in the <code>println!</code> macro to display its value.</li>
</ul>
<h3 id="22-constants-cannot-be-mutable"><a class="header" href="#22-constants-cannot-be-mutable">2.2 Constants Cannot Be Mutable</a></h3>
<p>One of the primary rules for constants is that they cannot be declared as mutable. Any attempt to use the <code>mut</code> keyword with a constant will result in a compilation error.</p>
<h4 id="example-attempting-to-make-a-constant-mutable"><a class="header" href="#example-attempting-to-make-a-constant-mutable">Example: Attempting to Make a Constant Mutable</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    const mut X: i32 = 5; // ERROR: Cannot use `mut` with a constant
}</code></pre></pre>
<h4 id="compilation-error"><a class="header" href="#compilation-error">Compilation Error</a></h4>
<pre><code>error: consts cannot be mutable
 --&gt; src/main.rs:2:10
  |
2 |     const mut X: i32 = 5;
  |          ^^^
</code></pre>
<h3 id="23-type-annotations-are-mandatory"><a class="header" href="#23-type-annotations-are-mandatory">2.3 Type Annotations Are Mandatory</a></h3>
<p>Unlike variables, where type inference is often sufficient, constants require explicit type annotations. The type must be specified when declaring a constant.</p>
<h4 id="example-missing-type-annotation"><a class="header" href="#example-missing-type-annotation">Example: Missing Type Annotation</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    const Z = 3.14; // ERROR: Missing type for `const` item
}</code></pre></pre>
<h4 id="fix-2"><a class="header" href="#fix-2">Fix</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    const Z: f64 = 3.14; // Correct: Type annotation is provided
}</code></pre></pre>
<h4 id="explanation-33"><a class="header" href="#explanation-33">Explanation</a></h4>
<ul>
<li><code>const Z: f64 = 3.14;</code> correctly declares the constant <code>Z</code> with the <code>f64</code> type.</li>
</ul>
<h3 id="24-constants-in-global-scope"><a class="header" href="#24-constants-in-global-scope">2.4 Constants in Global Scope</a></h3>
<p>Constants can be declared in the global scope, outside of the <code>main</code> function or any other function. This makes the constant accessible throughout the entire program.</p>
<h4 id="example-global-scope-constant"><a class="header" href="#example-global-scope-constant">Example: Global Scope Constant</a></h4>
<pre><pre class="playground"><code class="language-rust">const PI: f64 = 3.14;

fn main() {
    println!("The value of PI is: {}", PI);
}</code></pre></pre>
<h4 id="explanation-34"><a class="header" href="#explanation-34">Explanation</a></h4>
<ul>
<li><code>PI</code> is a constant declared in the global scope, making it accessible within the <code>main</code> function.</li>
</ul>
<h2 id="3-practical-examples"><a class="header" href="#3-practical-examples">3. Practical Examples</a></h2>
<h3 id="31-example-defining-a-constant-in-global-scope"><a class="header" href="#31-example-defining-a-constant-in-global-scope">3.1 Example: Defining a Constant in Global Scope</a></h3>
<pre><pre class="playground"><code class="language-rust">const HOURS_IN_SECONDS: u32 = 60 * 60 * 3; // 3 hours in seconds

fn main() {
    println!("3 hours in seconds is: {}", HOURS_IN_SECONDS);
}</code></pre></pre>
<h4 id="explanation-35"><a class="header" href="#explanation-35">Explanation</a></h4>
<ul>
<li><code>HOURS_IN_SECONDS</code> is a constant that calculates the number of seconds in 3 hours. This constant is defined globally and is accessible anywhere in the program.</li>
<li>The <code>println!</code> macro is used to display the calculated value.</li>
</ul>
<h3 id="32-example-using-constants-inside-functions"><a class="header" href="#32-example-using-constants-inside-functions">3.2 Example: Using Constants Inside Functions</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    const MAX_POINTS: u32 = 100_000;
    
    println!("The maximum points are: {}", MAX_POINTS);
}</code></pre></pre>
<h4 id="explanation-36"><a class="header" href="#explanation-36">Explanation</a></h4>
<ul>
<li><code>MAX_POINTS</code> is a constant defined inside the <code>main</code> function. Constants can be declared at any scope level, including within functions, but their immutability and type requirements remain.</li>
</ul>
<h2 id="4-summary-3"><a class="header" href="#4-summary-3">4. Summary</a></h2>
<p>In this lesson, we explored the concept of constants in Rust. Key takeaways include:</p>
<ul>
<li><strong>Immutability</strong>: Constants are immutable and cannot be changed after they are declared.</li>
<li><strong>Mandatory Type Annotations</strong>: Unlike variables, constants require explicit type annotations.</li>
<li><strong>Global Scope</strong>: Constants can be declared globally, making them accessible throughout the entire program.</li>
<li><strong>No Mutability</strong>: Constants cannot be made mutable; any attempt to do so will result in a compilation error.</li>
</ul>
<p>Understanding the rules and best practices for using constants is crucial for writing clear and efficient Rust code. Constants are particularly useful for values that need to remain consistent and unchanged throughout the execution of a program. In the next lesson, we will discuss the concept of shadowing in Rust and how it differs from mutability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h1>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p>In this lesson, we will explore the concept of <strong>shadowing</strong> in Rust. Shadowing allows you to declare a new variable with the same name as a previous variable, effectively replacing the old variable within a certain scope. This is different from simply making a variable mutable, as it allows for more flexibility, including the ability to change the variable's type. Understanding shadowing is essential for writing clear and idiomatic Rust code.</p>
<h2 id="1-what-is-shadowing"><a class="header" href="#1-what-is-shadowing">1. What is Shadowing?</a></h2>
<h3 id="11-definition"><a class="header" href="#11-definition">1.1 Definition</a></h3>
<p>Shadowing in Rust refers to the ability to declare a new variable with the same name as a previously declared variable. When a new variable is declared with the same name, it "shadows" the previous one, meaning the previous variable is no longer accessible in that scope, and the new variable takes precedence.</p>
<h3 id="12-how-shadowing-works"><a class="header" href="#12-how-shadowing-works">1.2 How Shadowing Works</a></h3>
<p>When you declare a new variable with the same name as an existing one, Rust allows the new variable to shadow the old one. This means that the new variable takes over, and the previous variable is effectively hidden within the scope where the shadowing occurs.</p>
<h4 id="example-basic-shadowing"><a class="header" href="#example-basic-shadowing">Example: Basic Shadowing</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5; // First declaration of `x`
    let x = x + 1; // Shadowing the first `x` with a new `x`
    
    println!("The value of x is: {}", x); // Prints 6
}</code></pre></pre>
<h4 id="explanation-37"><a class="header" href="#explanation-37">Explanation:</a></h4>
<ul>
<li>The first <code>x</code> is initialized with the value <code>5</code>.</li>
<li>The second <code>x</code> shadows the first <code>x</code>, adding <code>1</code> to its value, resulting in <code>6</code>.</li>
<li>When <code>x</code> is printed, it displays the value <code>6</code>, which corresponds to the shadowed <code>x</code>.</li>
</ul>
<h2 id="2-shadowing-vs-mutability"><a class="header" href="#2-shadowing-vs-mutability">2. Shadowing vs. Mutability</a></h2>
<h3 id="21-shadowing-is-not-mutability"><a class="header" href="#21-shadowing-is-not-mutability">2.1 Shadowing is Not Mutability</a></h3>
<p>It's important to understand that shadowing is different from marking a variable as mutable. While both allow a variable's value to change, shadowing does so by creating a new variable entirely, while mutability allows for in-place modification of an existing variable.</p>
<h4 id="example-attempt-to-modify-without-mutability"><a class="header" href="#example-attempt-to-modify-without-mutability">Example: Attempt to Modify Without Mutability</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    // x = 10; // ERROR: Cannot assign twice to immutable variable `x`
}</code></pre></pre>
<h4 id="explanation-38"><a class="header" href="#explanation-38">Explanation:</a></h4>
<ul>
<li>Attempting to reassign <code>x</code> without marking it as mutable results in a compilation error.</li>
<li>Shadowing avoids this by creating a new variable, which is not the same as modifying the original.</li>
</ul>
<h3 id="22-benefits-of-shadowing"><a class="header" href="#22-benefits-of-shadowing">2.2 Benefits of Shadowing</a></h3>
<p>Shadowing allows you to reuse variable names without needing to mark them as mutable, and it can even allow you to change the type of a variable while reusing its name.</p>
<h4 id="example-changing-type-with-shadowing"><a class="header" href="#example-changing-type-with-shadowing">Example: Changing Type with Shadowing</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let spaces = "   "; // `spaces` is a string slice
    let spaces = spaces.len(); // `spaces` is now an integer
    
    println!("The number of spaces is: {}", spaces);
}</code></pre></pre>
<h4 id="explanation-39"><a class="header" href="#explanation-39">Explanation:</a></h4>
<ul>
<li>The first <code>spaces</code> variable is a string slice containing spaces.</li>
<li>The second <code>spaces</code> variable shadows the first and stores the length of the string, changing its type to an integer.</li>
<li>This is a powerful use of shadowing, allowing you to reuse the same name while changing the data it holds.</li>
</ul>
<h2 id="3-shadowing-in-different-scopes"><a class="header" href="#3-shadowing-in-different-scopes">3. Shadowing in Different Scopes</a></h2>
<p>Shadowing can occur in different scopes, such as within nested blocks. When a variable is shadowed within a block, the original variable is still accessible outside that block.</p>
<h4 id="example-shadowing-in-nested-scopes"><a class="header" href="#example-shadowing-in-nested-scopes">Example: Shadowing in Nested Scopes</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    
    {
        let x = x * 2; // Shadows `x` within this block
        println!("The value of x in the inner scope is: {}", x); // Prints 10
    }
    
    println!("The value of x in the main scope is: {}", x); // Prints 5
}</code></pre></pre>
<h4 id="explanation-40"><a class="header" href="#explanation-40">Explanation:</a></h4>
<ul>
<li>The variable <code>x</code> is declared with the value <code>5</code> in the main scope.</li>
<li>Inside the nested block, a new <code>x</code> shadows the original <code>x</code>, doubling its value to <code>10</code>.</li>
<li>Outside the block, the original <code>x</code> remains unaffected and retains its value of <code>5</code>.</li>
</ul>
<h2 id="4-shadowing-and-type-changes"><a class="header" href="#4-shadowing-and-type-changes">4. Shadowing and Type Changes</a></h2>
<p>One of the unique features of shadowing is the ability to change the type of a variable while reusing the same name. This allows for more flexible and concise code, especially when dealing with different stages of data transformation.</p>
<h4 id="example-shadowing-to-change-type"><a class="header" href="#example-shadowing-to-change-type">Example: Shadowing to Change Type</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let guess = "42"; // `guess` is a string slice
    
    let guess: i32 = guess.trim().parse().expect("Not a number!"); // `guess` is now an i32
    
    println!("The guess is: {}", guess);
}</code></pre></pre>
<h4 id="explanation-41"><a class="header" href="#explanation-41">Explanation:</a></h4>
<ul>
<li>The initial <code>guess</code> is a string slice containing the text <code>"42"</code>.</li>
<li>The second <code>guess</code> shadows the first and parses the string into an integer (<code>i32</code>).</li>
<li>This allows for seamless type conversion while maintaining the same variable name.</li>
</ul>
<h2 id="5-common-pitfalls-and-error-handling"><a class="header" href="#5-common-pitfalls-and-error-handling">5. Common Pitfalls and Error Handling</a></h2>
<h3 id="51-reassigning-without-shadowing-or-mutability"><a class="header" href="#51-reassigning-without-shadowing-or-mutability">5.1 Reassigning Without Shadowing or Mutability</a></h3>
<p>If you attempt to reassign a value to a variable without using <code>let</code> for shadowing or <code>mut</code> for mutability, Rust will produce a compile-time error.</p>
<h4 id="example-error-in-reassignment"><a class="header" href="#example-error-in-reassignment">Example: Error in Reassignment</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    x = 10; // ERROR: Cannot assign twice to immutable variable `x`
}</code></pre></pre>
<h3 id="52-mutability-vs-shadowing"><a class="header" href="#52-mutability-vs-shadowing">5.2 Mutability vs. Shadowing</a></h3>
<p>Shadowing creates a new variable, while mutability modifies the existing one. Shadowing allows you to declare a new variable with the same name, effectively creating a fresh variable that can even have a different type, whereas mutability does not.</p>
<h2 id="6-summary"><a class="header" href="#6-summary">6. Summary</a></h2>
<p>In this lesson, we covered the concept of shadowing in Rust. Key takeaways include:</p>
<ul>
<li><strong>Shadowing</strong> allows you to declare a new variable with the same name as an existing one, effectively replacing the old variable in that scope.</li>
<li><strong>Difference from Mutability</strong>: Unlike mutability, which modifies an existing variable, shadowing creates a new variable that can even have a different type.</li>
<li><strong>Scope and Flexibility</strong>: Shadowing can be used in different scopes and allows for flexible data transformation by reusing variable names.</li>
</ul>
<p>Shadowing is a powerful feature in Rust that, when used appropriately, can make your code more concise and clear. In the next lesson, we will explore more advanced topics that build on the concepts of variables, mutability, and shadowing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<p>In this lesson, we will explore the importance and usage of comments in Rust. Comments are an essential part of programming, providing clarity and context for your code. They are particularly valuable when working in teams, as they help other developers understand the intent and functionality of your code. Although comments are ignored by the compiler, they play a critical role in maintaining readable and maintainable code.</p>
<h2 id="1-why-are-comments-important"><a class="header" href="#1-why-are-comments-important">1. Why Are Comments Important?</a></h2>
<p>Comments serve several key purposes in programming:</p>
<ul>
<li><strong>Documentation</strong>: Comments help document the code, explaining what specific blocks of code do, especially complex or non-obvious sections.</li>
<li><strong>Collaboration</strong>: In team environments, comments facilitate communication by explaining the purpose and functionality of code to other developers.</li>
<li><strong>Maintenance</strong>: Comments make it easier to revisit and understand the code after some time has passed, aiding in debugging and future development.</li>
</ul>
<h2 id="2-types-of-comments-in-rust"><a class="header" href="#2-types-of-comments-in-rust">2. Types of Comments in Rust</a></h2>
<p>Rust supports two main types of comments:</p>
<ul>
<li><strong>Line Comments</strong></li>
<li><strong>Block Comments</strong></li>
</ul>
<h3 id="21-line-comments"><a class="header" href="#21-line-comments">2.1 Line Comments</a></h3>
<p>Line comments are used to comment out a single line or part of a line of code. They begin with <code>//</code> and continue to the end of the line. These comments can be placed on their own line or at the end of a line of code.</p>
<h4 id="example-line-comments"><a class="header" href="#example-line-comments">Example: Line Comments</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // This is a line comment explaining the next line of code
    println!("Hello, world!"); // This prints "Hello, world!" to the console
}</code></pre></pre>
<h4 id="explanation-42"><a class="header" href="#explanation-42">Explanation</a></h4>
<ul>
<li>The first comment explains the purpose of the <code>println!</code> statement.</li>
<li>The second comment is placed at the end of the line to provide additional context directly next to the code it describes.</li>
</ul>
<h3 id="22-block-comments"><a class="header" href="#22-block-comments">2.2 Block Comments</a></h3>
<p>Block comments are used to comment out multiple lines of code or to provide detailed explanations that span several lines. Block comments begin with <code>/*</code> and end with <code>*/</code>. They can span multiple lines, making them ideal for larger comments.</p>
<h4 id="example-block-comments"><a class="header" href="#example-block-comments">Example: Block Comments</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    /*
    This is a block comment that spans multiple lines.
    It is useful for providing detailed explanations or temporarily disabling code.
    */
    println!("Hello, Rust!");
}</code></pre></pre>
<h4 id="explanation-43"><a class="header" href="#explanation-43">Explanation</a></h4>
<ul>
<li>Block comments allow you to comment out multiple lines without needing to prefix each line with <code>//</code>.</li>
<li>They are particularly useful for adding detailed explanations or for temporarily disabling a section of code during debugging.</li>
</ul>
<h3 id="23-nested-block-comments"><a class="header" href="#23-nested-block-comments">2.3 Nested Block Comments</a></h3>
<p>Rust supports <strong>nested block comments</strong>, which means you can place one block comment inside another. This feature is particularly useful when you want to comment out a large block of code that already contains block comments.</p>
<h4 id="example-nested-block-comments"><a class="header" href="#example-nested-block-comments">Example: Nested Block Comments</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    /*
    This is the outer block comment.
    /* 
    This is a nested block comment inside the outer one.
    */
    This part is still within the outer block comment.
    */
    println!("Hello, world!");
}</code></pre></pre>
<h4 id="explanation-44"><a class="header" href="#explanation-44">Explanation</a></h4>
<ul>
<li>The ability to nest block comments allows you to comment out sections of code that already include comments without causing syntax errors.</li>
</ul>
<h2 id="3-best-practices-for-using-comments"><a class="header" href="#3-best-practices-for-using-comments">3. Best Practices for Using Comments</a></h2>
<p>While comments are valuable, it's important to use them effectively. Here are some best practices to consider:</p>
<ul>
<li><strong>Keep Comments Relevant</strong>: Ensure that comments accurately describe the code they reference. Outdated or incorrect comments can be misleading.</li>
<li><strong>Avoid Redundant Comments</strong>: Do not state the obvious. Comments should add value, not reiterate what the code already clearly expresses.</li>
<li><strong>Use Comments for Complex Logic</strong>: Focus on commenting complex or non-intuitive parts of the code. Simple operations generally do not need comments.</li>
<li><strong>Maintain Updated Comments</strong>: When modifying code, always update the associated comments to reflect the changes.</li>
</ul>
<h2 id="4-commenting-techniques-in-practice"><a class="header" href="#4-commenting-techniques-in-practice">4. Commenting Techniques in Practice</a></h2>
<h3 id="41-commenting-out-code-for-debugging"><a class="header" href="#41-commenting-out-code-for-debugging">4.1 Commenting Out Code for Debugging</a></h3>
<p>During development, you might need to temporarily disable certain lines of code to test or debug other parts of your program. Comments are a quick and effective way to do this.</p>
<h4 id="example-commenting-out-code"><a class="header" href="#example-commenting-out-code">Example: Commenting Out Code</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Start of the program");
    
    // println!("This line is commented out and will not be executed");
    
    println!("End of the program");
}</code></pre></pre>
<h4 id="explanation-45"><a class="header" href="#explanation-45">Explanation</a></h4>
<ul>
<li>The commented-out line will not be executed when the program runs, allowing you to test the remaining code without removing the line entirely.</li>
</ul>
<h3 id="42-documenting-functions-and-modules"><a class="header" href="#42-documenting-functions-and-modules">4.2 Documenting Functions and Modules</a></h3>
<p>In addition to inline comments, Rust encourages the use of documentation comments to describe functions, modules, and structs. Documentation comments are written using triple slashes (<code>///</code>) and can be processed by tools like <code>rustdoc</code> to generate HTML documentation.</p>
<h4 id="example-documentation-comments"><a class="header" href="#example-documentation-comments">Example: Documentation Comments</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adds two numbers together.
/// 
/// # Arguments
/// 
/// * `a` - The first number
/// * `b` - The second number
/// 
/// # Returns
/// 
/// The sum of `a` and `b`.
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<h4 id="explanation-46"><a class="header" href="#explanation-46">Explanation</a></h4>
<ul>
<li>Documentation comments provide detailed information about the function, including its purpose, arguments, and return value.</li>
<li>These comments can be compiled into documentation, making it easier for others to understand and use your code.</li>
</ul>
<h2 id="5-summary-1"><a class="header" href="#5-summary-1">5. Summary</a></h2>
<p>In this lesson, we covered the importance of comments in Rust and how to use them effectively. Key points include:</p>
<ul>
<li><strong>Line Comments</strong>: Use <code>//</code> for single-line comments, either on their own line or at the end of a line of code.</li>
<li><strong>Block Comments</strong>: Use <code>/* */</code> for multi-line comments, which can also be nested.</li>
<li><strong>Best Practices</strong>: Keep comments relevant, avoid redundancy, and ensure comments are updated when code changes.</li>
<li><strong>Documentation Comments</strong>: Use <code>///</code> for generating documentation that explains the functionality of your code.</li>
</ul>
<p>Comments are a vital part of writing maintainable and understandable code. While they do not affect the execution of your program, their presence can greatly enhance the readability and usability of your code, especially in collaborative environments. In the next lesson, we will delve into more advanced Rust features that build on the fundamentals we've covered so far.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-else-statements--control-flow"><a class="header" href="#if-else-statements--control-flow">If Else Statements / Control Flow</a></h1>
<h2 id="overview-9"><a class="header" href="#overview-9">Overview</a></h2>
<p>In this lesson, we will explore control flow in Rust, focusing on <code>if-else</code> expressions. Control flow is an essential concept in programming, determining how the program executes different blocks of code based on conditions. In Rust, as in other programming languages, <code>if-else</code> expressions allow you to branch your code depending on whether certain conditions are true or false. Mastering control flow is crucial for building complex and responsive applications.</p>
<h2 id="1-introduction-to-control-flow"><a class="header" href="#1-introduction-to-control-flow">1. Introduction to Control Flow</a></h2>
<h3 id="11-what-is-control-flow"><a class="header" href="#11-what-is-control-flow">1.1 What is Control Flow?</a></h3>
<p>Control flow refers to the order in which individual statements, instructions, or function calls are executed or evaluated in a programming language. In Rust, control flow is primarily managed through:</p>
<ul>
<li><strong>Conditions</strong>: Checking if certain criteria are met.</li>
<li><strong>Repeating actions</strong>: Looping over blocks of code based on conditions.</li>
</ul>
<p>In this lesson, we will focus on how conditions are handled in Rust using <code>if-else</code> expressions.</p>
<h3 id="12-if-else-expressions"><a class="header" href="#12-if-else-expressions">1.2 If-Else Expressions</a></h3>
<p>An <code>if</code> expression in Rust allows you to execute a block of code based on whether a condition evaluates to true. The <code>else</code> clause provides an alternative block of code to execute if the condition is false.</p>
<h4 id="example-basic-if-else-expression"><a class="header" href="#example-basic-if-else-expression">Example: Basic If-Else Expression</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let age = 18;

    if age &gt;= 18 {
        println!("You can drive a car.");
    } else {
        println!("You are not old enough to drive.");
    }
}</code></pre></pre>
<h4 id="explanation-47"><a class="header" href="#explanation-47">Explanation:</a></h4>
<ul>
<li>The condition <code>age &gt;= 18</code> is checked.</li>
<li>If the condition is true, the program prints "You can drive a car."</li>
<li>If the condition is false, it prints "You are not old enough to drive."</li>
</ul>
<h2 id="2-using-if-else-statements"><a class="header" href="#2-using-if-else-statements">2. Using If-Else Statements</a></h2>
<h3 id="21-simple-if-statement"><a class="header" href="#21-simple-if-statement">2.1 Simple If Statement</a></h3>
<p>The most basic control flow statement is the <code>if</code> statement. It checks a condition and executes the associated block of code if the condition is true.</p>
<h4 id="example-simple-if-statement"><a class="header" href="#example-simple-if-statement">Example: Simple If Statement</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let temperature = 30;

    if temperature &gt; 25 {
        println!("It's a hot day!");
    }
}</code></pre></pre>
<h4 id="explanation-48"><a class="header" href="#explanation-48">Explanation:</a></h4>
<ul>
<li>The condition <code>temperature &gt; 25</code> is evaluated.</li>
<li>Since the temperature is 30, which is greater than 25, the program prints "It's a hot day!"</li>
</ul>
<h3 id="22-if-else-statement"><a class="header" href="#22-if-else-statement">2.2 If-Else Statement</a></h3>
<p>An <code>if-else</code> statement allows you to specify an alternative block of code to execute when the condition is false.</p>
<h4 id="example-if-else-statement"><a class="header" href="#example-if-else-statement">Example: If-Else Statement</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let age = 16;

    if age &gt;= 18 {
        println!("You can drive a car.");
    } else {
        println!("You are not old enough to drive.");
    }
}</code></pre></pre>
<h4 id="explanation-49"><a class="header" href="#explanation-49">Explanation:</a></h4>
<ul>
<li>The condition <code>age &gt;= 18</code> is false because the age is 16.</li>
<li>The <code>else</code> block is executed, printing "You are not old enough to drive."</li>
</ul>
<h3 id="23-multiple-conditions-with-else-if"><a class="header" href="#23-multiple-conditions-with-else-if">2.3 Multiple Conditions with Else If</a></h3>
<p>Sometimes, you need to check multiple conditions. This is where <code>else if</code> comes in handy. It allows you to test additional conditions if the previous ones are false.</p>
<h4 id="example-else-if-statement"><a class="header" href="#example-else-if-statement">Example: Else If Statement</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("The number is divisible by 4.");
    } else if number % 3 == 0 {
        println!("The number is divisible by 3.");
    } else if number % 2 == 0 {
        println!("The number is divisible by 2.");
    } else {
        println!("The number is not divisible by 4, 3, or 2.");
    }
}</code></pre></pre>
<h4 id="explanation-50"><a class="header" href="#explanation-50">Explanation:</a></h4>
<ul>
<li>The program checks if <code>number</code> is divisible by 4, then by 3, and then by 2.</li>
<li>Since 6 is divisible by 3, the corresponding block of code is executed, and "The number is divisible by 3." is printed.</li>
</ul>
<h2 id="3-if-in-a-let-statement"><a class="header" href="#3-if-in-a-let-statement">3. If in a Let Statement</a></h2>
<p>In Rust, you can use <code>if-else</code> expressions to assign values to variables. This can be particularly useful for making decisions within a single line of code.</p>
<h4 id="example-if-else-in-a-let-statement"><a class="header" href="#example-if-else-in-a-let-statement">Example: If-Else in a Let Statement</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The number is: {}", number);
}</code></pre></pre>
<h4 id="explanation-51"><a class="header" href="#explanation-51">Explanation:</a></h4>
<ul>
<li>The variable <code>number</code> is assigned the value <code>5</code> if <code>condition</code> is true, or <code>6</code> if <code>condition</code> is false.</li>
<li>Since <code>condition</code> is true, <code>number</code> is set to <code>5</code>, and the program prints "The number is: 5."</li>
</ul>
<h3 id="31-ensuring-compatible-types"><a class="header" href="#31-ensuring-compatible-types">3.1 Ensuring Compatible Types</a></h3>
<p>It is important to ensure that both branches of an <code>if-else</code> expression return values of the same type. If the types are incompatible, Rust will produce a compilation error.</p>
<h4 id="example-incompatible-types-in-if-else"><a class="header" href="#example-incompatible-types-in-if-else">Example: Incompatible Types in If-Else</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = false;
    let number = if condition { 5 } else { "six" }; // ERROR: Incompatible types

    println!("The number is: {}", number);
}</code></pre></pre>
<h4 id="compilation-error-1"><a class="header" href="#compilation-error-1">Compilation Error:</a></h4>
<pre><code>error[E0308]: if and else have incompatible types
 --&gt; src/main.rs:3:34
  |
3 |     let number = if condition { 5 } else { "six" };
  |                                  ^ expected integer, found `&amp;str`
</code></pre>
<h4 id="explanation-52"><a class="header" href="#explanation-52">Explanation:</a></h4>
<ul>
<li>The <code>if</code> branch returns an integer, while the <code>else</code> branch returns a string. Rust requires both branches to return values of the same type, so this code results in a compilation error.</li>
</ul>
<h2 id="4-summary-4"><a class="header" href="#4-summary-4">4. Summary</a></h2>
<p>In this lesson, we covered the basics of control flow in Rust, focusing on <code>if-else</code> expressions. Key points include:</p>
<ul>
<li><strong>If Statements</strong>: Execute a block of code if a condition is true.</li>
<li><strong>If-Else Statements</strong>: Provide an alternative block of code if the condition is false.</li>
<li><strong>Else If Statements</strong>: Check additional conditions when the previous conditions are false.</li>
<li><strong>If in Let Statements</strong>: Assign values based on conditions directly within a <code>let</code> statement.</li>
<li><strong>Type Compatibility</strong>: Ensure that all branches of an <code>if-else</code> expression return the same type to avoid compilation errors.</li>
</ul>
<p>Understanding and effectively using control flow is essential for writing flexible and responsive Rust programs. In the next lesson, we will explore loops, another critical aspect of control flow, which allows for repeating actions based on conditions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops--control-flow"><a class="header" href="#loops--control-flow">Loops / Control Flow</a></h1>
<h2 id="overview-10"><a class="header" href="#overview-10">Overview</a></h2>
<p>In this lesson, we will explore the concept of loops in Rust, a fundamental aspect of control flow. Loops allow you to execute a block of code multiple times, which is crucial for tasks that require repetition, such as iterating over a collection or retrying an operation until a condition is met. Rust provides three primary loop constructs: <code>loop</code>, <code>while</code>, and <code>for</code>. Each of these loops serves different purposes and offers unique control over the flow of your program.</p>
<h2 id="1-types-of-loops-in-rust"><a class="header" href="#1-types-of-loops-in-rust">1. Types of Loops in Rust</a></h2>
<h3 id="11-loop---the-infinite-loop"><a class="header" href="#11-loop---the-infinite-loop">1.1 <code>loop</code> - The Infinite Loop</a></h3>
<p>The <code>loop</code> keyword in Rust creates an unconditional loop that will run indefinitely unless explicitly stopped using the <code>break</code> statement. This type of loop is useful when you want to repeat a block of code until a specific condition is met from within the loop.</p>
<h4 id="example-basic-infinite-loop"><a class="header" href="#example-basic-infinite-loop">Example: Basic Infinite Loop</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    loop {
        println!("Hello, world!");
    }
}</code></pre></pre>
<h4 id="explanation-53"><a class="header" href="#explanation-53">Explanation:</a></h4>
<ul>
<li>The <code>loop</code> will continuously print "Hello, world!" until manually interrupted (e.g., by pressing <code>Ctrl+C</code> in the terminal).</li>
</ul>
<h3 id="12-breaking-a-loop"><a class="header" href="#12-breaking-a-loop">1.2 Breaking a Loop</a></h3>
<p>To stop an infinite loop, you use the <code>break</code> statement. This is often paired with a conditional check to exit the loop when a certain condition is met.</p>
<h4 id="example-loop-with-break"><a class="header" href="#example-loop-with-break">Example: Loop with Break</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    loop {
        counter += 1;

        if counter == 10 {
            break;
        }
    }

    println!("Counter reached: {}", counter);
}</code></pre></pre>
<h4 id="explanation-54"><a class="header" href="#explanation-54">Explanation:</a></h4>
<ul>
<li>The loop increments <code>counter</code> by 1 on each iteration.</li>
<li>When <code>counter</code> reaches 10, the <code>break</code> statement exits the loop, and the final value of <code>counter</code> is printed.</li>
</ul>
<h3 id="13-returning-values-from-loops"><a class="header" href="#13-returning-values-from-loops">1.3 Returning Values from Loops</a></h3>
<p>Rust allows you to return a value from a loop by placing the value after the <code>break</code> statement. This can be useful when you need to perform an operation repeatedly until a desired result is achieved.</p>
<h4 id="example-returning-a-value-from-a-loop"><a class="header" href="#example-returning-a-value-from-a-loop">Example: Returning a Value from a Loop</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is: {}", result);
}</code></pre></pre>
<h4 id="explanation-55"><a class="header" href="#explanation-55">Explanation:</a></h4>
<ul>
<li>The loop runs until <code>counter</code> equals 10.</li>
<li>When the loop breaks, it returns <code>counter * 2</code>, which is 20 in this case, and assigns it to <code>result</code>.</li>
</ul>
<h2 id="2-loop-labels"><a class="header" href="#2-loop-labels">2. Loop Labels</a></h2>
<h3 id="21-nested-loops-and-labels"><a class="header" href="#21-nested-loops-and-labels">2.1 Nested Loops and Labels</a></h3>
<p>When working with nested loops, it can become unclear which loop a <code>break</code> or <code>continue</code> statement is referring to. Rust provides loop labels to clarify this by explicitly naming loops and specifying which loop should be affected by <code>break</code> or <code>continue</code>.</p>
<h4 id="example-using-loop-labels"><a class="header" href="#example-using-loop-labels">Example: Using Loop Labels</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut count = 0;

    'outer: loop {
        println!("Count = {}", count);
        let mut remaining = 10;

        loop {
            println!("Remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'outer;
            }
            remaining -= 1;
        }

        count += 1;
    }

    println!("End of loop with count = {}", count);
}</code></pre></pre>
<h4 id="explanation-56"><a class="header" href="#explanation-56">Explanation:</a></h4>
<ul>
<li>The <code>outer</code> loop is labeled with <code>'outer:</code>.</li>
<li>The inner loop decreases <code>remaining</code> until it equals 9, then breaks out of the inner loop.</li>
<li>When <code>count</code> equals 2, the program breaks out of the <code>outer</code> loop using the <code>'outer</code> label.</li>
</ul>
<h2 id="3-while-loops"><a class="header" href="#3-while-loops">3. <code>while</code> Loops</a></h2>
<h3 id="31-conditional-loops"><a class="header" href="#31-conditional-loops">3.1 Conditional Loops</a></h3>
<p>The <code>while</code> loop runs as long as a specified condition is true. This loop is useful for scenarios where the number of iterations is not known beforehand, and the loop needs to continue until a condition changes.</p>
<h4 id="example-while-loop"><a class="header" href="#example-while-loop">Example: While Loop</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("Liftoff!");
}</code></pre></pre>
<h4 id="explanation-57"><a class="header" href="#explanation-57">Explanation:</a></h4>
<ul>
<li>The <code>while</code> loop runs as long as <code>number</code> is not equal to 0.</li>
<li>Each iteration prints the current value of <code>number</code> and then decrements it by 1.</li>
<li>When <code>number</code> reaches 0, the loop exits and "Liftoff!" is printed.</li>
</ul>
<h2 id="4-for-loops"><a class="header" href="#4-for-loops">4. <code>for</code> Loops</a></h2>
<h3 id="41-iterating-over-a-collection"><a class="header" href="#41-iterating-over-a-collection">4.1 Iterating Over a Collection</a></h3>
<p>The <code>for</code> loop in Rust is used to iterate over collections such as arrays or ranges. It automatically handles iteration and avoids the common pitfalls associated with manually managing loop counters.</p>
<h4 id="example-iterating-over-an-array"><a class="header" href="#example-iterating-over-an-array">Example: Iterating Over an Array</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    for element in a {
        println!("The value is: {}", element);
    }
}</code></pre></pre>
<h4 id="explanation-58"><a class="header" href="#explanation-58">Explanation:</a></h4>
<ul>
<li>The <code>for</code> loop iterates over each element in the array <code>a</code>.</li>
<li>Each value is printed during its respective iteration.</li>
</ul>
<h3 id="42-iterating-over-a-range"><a class="header" href="#42-iterating-over-a-range">4.2 Iterating Over a Range</a></h3>
<p>Rust’s <code>for</code> loop can also iterate over a range of numbers, which is especially useful for counting up or down.</p>
<h4 id="example-iterating-over-a-range"><a class="header" href="#example-iterating-over-a-range">Example: Iterating Over a Range</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in 1..4 {
        println!("The number is: {}", number);
    }
}</code></pre></pre>
<h4 id="explanation-59"><a class="header" href="#explanation-59">Explanation:</a></h4>
<ul>
<li>The <code>for</code> loop iterates over the range <code>1..4</code>, printing the numbers 1 through 3.</li>
<li>Note that the range <code>1..4</code> is exclusive of 4.</li>
</ul>
<h2 id="5-summary-2"><a class="header" href="#5-summary-2">5. Summary</a></h2>
<p>In this lesson, we explored the different types of loops in Rust, each serving a unique purpose:</p>
<ul>
<li><strong><code>loop</code></strong>: An unconditional loop that continues until explicitly stopped using <code>break</code>.</li>
<li><strong><code>while</code></strong>: A conditional loop that continues as long as a condition is true.</li>
<li><strong><code>for</code></strong>: A loop that iterates over collections or ranges, automatically handling iteration logic.</li>
</ul>
<p>Understanding how and when to use each type of loop is crucial for controlling the flow of your Rust programs effectively. These loops are powerful tools for iterating over data, performing repetitive tasks, and managing complex control flows in your applications. In the next lesson, we will delve deeper into more advanced Rust features that build on these foundational concepts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-and-implementing-structs-in-rust"><a class="header" href="#understanding-and-implementing-structs-in-rust">Understanding and Implementing Structs in Rust</a></h1>
<p>Structs in Rust are one of the most fundamental data structures, used to encapsulate related data fields under a single name. Structs allow you to group and name multiple related values, making your code more readable and maintainable. This tutorial will guide you through the concept of structs in Rust, covering their definition, instantiation, field access, and advanced usage scenarios.</p>
<h2 id="1-introduction-to-structs"><a class="header" href="#1-introduction-to-structs">1. Introduction to Structs</a></h2>
<p>In Rust, structs are similar to tuples but with named fields, providing clearer and more expressive ways to structure your data. Each field in a struct has a name and a type, and the fields can have different types, making structs highly versatile.</p>
<h3 id="syntax"><a class="header" href="#syntax">Syntax:</a></h3>
<p>To define a struct, use the following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StructName {
    field1: Type1,
    field2: Type2,
    // Additional fields
}
<span class="boring">}</span></code></pre></pre>
<p>This defines a struct named <code>StructName</code> with fields <code>field1</code> and <code>field2</code>, each having a specific type.</p>
<h2 id="2-creating-structs"><a class="header" href="#2-creating-structs">2. Creating Structs</a></h2>
<p>Let's define two structs: <code>Book</code> and <code>User</code>, which will serve as examples for understanding how to use structs.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define the Book struct
struct Book {
    title: String,
    author: String,
    pages: u32,
    available: bool,
}

// Define the User struct
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-60"><a class="header" href="#explanation-60">Explanation:</a></h3>
<ul>
<li><code>Book</code>: Represents a book with a title, author, number of pages, and availability status.</li>
<li><code>User</code>: Represents a user with an active status, username, email, and sign-in count.</li>
</ul>
<h2 id="3-instantiating-structs"><a class="header" href="#3-instantiating-structs">3. Instantiating Structs</a></h2>
<p>To create an instance of a struct, you provide values for each field. This is similar to initializing an object in other programming languages.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instantiate a Book struct
let my_book = Book {
    title: String::from("Rust Programming"),
    author: String::from("John Doe"),
    pages: 200,
    available: true,
};

// Instantiate a User struct
let user1 = User {
    active: true,
    username: String::from("example_user"),
    email: String::from("user@example.com"),
    sign_in_count: 1,
};
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-61"><a class="header" href="#explanation-61">Explanation:</a></h3>
<ul>
<li><code>my_book</code>: An instance of the <code>Book</code> struct representing a book titled "Rust Programming" by "John Doe".</li>
<li><code>user1</code>: An instance of the <code>User</code> struct representing a user with the username "example_user".</li>
</ul>
<h2 id="4-accessing-and-modifying-struct-fields"><a class="header" href="#4-accessing-and-modifying-struct-fields">4. Accessing and Modifying Struct Fields</a></h2>
<p>You can access and modify the fields of a struct using dot notation. If you need to modify a field, the entire struct instance must be mutable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Access and modify struct fields
let mut user2 = User {
    active: false,
    username: String::from("another_user"),
    email: String::from("another@example.com"),
    sign_in_count: 0,
};

// Modify the email field
user2.email = String::from("new_email@example.com");
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-62"><a class="header" href="#explanation-62">Explanation:</a></h3>
<ul>
<li><code>user2</code>: A mutable instance of the <code>User</code> struct.</li>
<li>The <code>email</code> field of <code>user2</code> is updated using dot notation.</li>
</ul>
<h2 id="5-returning-structs-from-functions"><a class="header" href="#5-returning-structs-from-functions">5. Returning Structs from Functions</a></h2>
<p>Functions in Rust can return instances of structs, allowing for encapsulated logic to build and return data structures.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define a function that returns a User struct
fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        email, // Field shorthand for email: email
        username, // Field shorthand for username: username
        sign_in_count: 1,
    }
}

// Use the function to create a User struct
let user3 = build_user(String::from("user3@example.com"), String::from("user3"));
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-63"><a class="header" href="#explanation-63">Explanation:</a></h3>
<ul>
<li><code>build_user</code>: A function that creates and returns a <code>User</code> struct. The function takes an email and username as input and initializes the other fields with default values.</li>
<li>The shorthand syntax (<code>email, username</code>) is used to simplify initialization when the field name and variable name are the same.</li>
</ul>
<h2 id="6-creating-instances-from-other-instances"><a class="header" href="#6-creating-instances-from-other-instances">6. Creating Instances from Other Instances</a></h2>
<p>Rust allows you to create a new struct instance by copying some fields from another instance. This is done using the struct update syntax.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create a new User instance based on user1 but with a different email
let user4 = User {
    email: String::from("user4@example.com"), // New email
    ..user1 // Reuse other fields from user1
};
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-64"><a class="header" href="#explanation-64">Explanation:</a></h3>
<ul>
<li><code>user4</code>: A new instance of <code>User</code> that reuses most of the fields from <code>user1</code> but changes the <code>email</code> field.</li>
<li>The <code>..user1</code> syntax copies the remaining fields from <code>user1</code> to <code>user4</code>.</li>
</ul>
<h2 id="7-tuple-structs-and-unit-like-structs"><a class="header" href="#7-tuple-structs-and-unit-like-structs">7. Tuple Structs and Unit-Like Structs</a></h2>
<p>Rust also supports tuple structs and unit-like structs, which offer different ways to define and use data structures.</p>
<h3 id="71-tuple-structs"><a class="header" href="#71-tuple-structs">7.1 Tuple Structs</a></h3>
<p>Tuple structs are similar to regular structs but without named fields. They are useful when you need a named tuple with specific types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define a tuple struct
struct Color(i32, i32, i32);

// Instantiate tuple structs
let black = Color(0, 0, 0);
let white = Color(255, 255, 255);
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-65"><a class="header" href="#explanation-65">Explanation:</a></h3>
<ul>
<li><code>Color</code>: A tuple struct representing an RGB color with three <code>i32</code> values.</li>
</ul>
<h3 id="72-unit-like-structs"><a class="header" href="#72-unit-like-structs">7.2 Unit-Like Structs</a></h3>
<p>Unit-like structs have no fields and are typically used when implementing traits without needing to store data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define a unit-like struct
struct AlwaysEqual;

// Instantiate a unit-like struct
let always = AlwaysEqual;
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-66"><a class="header" href="#explanation-66">Explanation:</a></h3>
<ul>
<li><code>AlwaysEqual</code>: A unit-like struct that can be used when you need a type but don’t need to store any data.</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Structs in Rust are versatile tools for organizing and managing data. They allow you to encapsulate related fields into a single, named entity, providing both clarity and structure to your programs. By understanding how to define, instantiate, and manipulate structs, as well as how to use advanced features like tuple structs and unit-like structs, you can write more expressive and maintainable Rust code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-and-implementing-enums-in-rust"><a class="header" href="#understanding-and-implementing-enums-in-rust">Understanding and Implementing Enums in Rust</a></h1>
<p>Enums, short for "enumerations," are a powerful feature in Rust that allows you to define a type by enumerating its possible values. Enums are used to represent data that can take on different but related forms, making them ideal for scenarios where a value could be one of several variants. This tutorial will guide you through the concept of enums in Rust, covering their definition, instantiation, pattern matching, and advanced usage.</p>
<h2 id="1-introduction-to-enums"><a class="header" href="#1-introduction-to-enums">1. Introduction to Enums</a></h2>
<p>Enums in Rust enable you to define a type by listing its possible variants. Each variant can optionally carry additional data, making enums more flexible than just a list of named constants.</p>
<h3 id="syntax-1"><a class="header" href="#syntax-1">Syntax:</a></h3>
<p>To define an enum, use the following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum EnumName {
    Variant1,
    Variant2,
    // Additional variants
}
<span class="boring">}</span></code></pre></pre>
<p>This defines an enum named <code>EnumName</code> with two variants: <code>Variant1</code> and <code>Variant2</code>. Each variant can also store data, similar to a struct.</p>
<h2 id="2-creating-and-using-enums"><a class="header" href="#2-creating-and-using-enums">2. Creating and Using Enums</a></h2>
<p>Let's define an enum <code>Message</code> that demonstrates how enums can store different types of data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define the Message enum
enum Message {
    Quit,                      // No associated data
    Move { x: i32, y: i32 },   // Named fields like a struct
    Write(String),             // Single String value
    ChangeColor(i32, i32, i32) // Three i32 values (e.g., RGB color)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-67"><a class="header" href="#explanation-67">Explanation:</a></h3>
<ul>
<li><code>Quit</code>: A variant with no data.</li>
<li><code>Move</code>: A variant that includes two named fields, <code>x</code> and <code>y</code>.</li>
<li><code>Write</code>: A variant that holds a single <code>String</code> value.</li>
<li><code>ChangeColor</code>: A variant that holds three <code>i32</code> values, such as for representing an RGB color.</li>
</ul>
<h2 id="3-instantiating-enums"><a class="header" href="#3-instantiating-enums">3. Instantiating Enums</a></h2>
<p>You can create instances of an enum by specifying one of its variants and any associated data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instantiate enum variants
let quit_message = Message::Quit;
let move_message = Message::Move { x: 10, y: 20 };
let write_message = Message::Write(String::from("Hello, Rust!"));
let change_color_message = Message::ChangeColor(255, 0, 0);
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-68"><a class="header" href="#explanation-68">Explanation:</a></h3>
<ul>
<li><code>quit_message</code>: An instance of the <code>Quit</code> variant.</li>
<li><code>move_message</code>: An instance of the <code>Move</code> variant with <code>x</code> and <code>y</code> fields set to 10 and 20, respectively.</li>
<li><code>write_message</code>: An instance of the <code>Write</code> variant holding the string "Hello, Rust!".</li>
<li><code>change_color_message</code>: An instance of the <code>ChangeColor</code> variant with RGB values representing the color red.</li>
</ul>
<h2 id="4-matching-with-enums"><a class="header" href="#4-matching-with-enums">4. Matching with Enums</a></h2>
<p>One of the most powerful features of enums in Rust is their integration with pattern matching. The <code>match</code> expression allows you to branch your code based on which variant of an enum is being used.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_message(message: Message) {
    match message {
        Message::Quit =&gt; {
            println!("The Quit variant has no data to process.");
        },
        Message::Move { x, y } =&gt; {
            println!("Move to coordinates: x = {}, y = {}", x, y);
        },
        Message::Write(text) =&gt; {
            println!("Text message: {}", text);
        },
        Message::ChangeColor(r, g, b) =&gt; {
            println!("Change color to red = {}, green = {}, blue = {}", r, g, b);
        },
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-69"><a class="header" href="#explanation-69">Explanation:</a></h3>
<ul>
<li>The <code>match</code> expression checks which variant of <code>Message</code> was passed to the <code>process_message</code> function.</li>
<li>For each variant, it executes the corresponding code block, with the ability to destructure the variant's associated data.</li>
</ul>
<h2 id="5-the-option-enum"><a class="header" href="#5-the-option-enum">5. The <code>Option</code> Enum</a></h2>
<p>Rust includes a built-in enum called <code>Option</code>, which is used to express the presence or absence of a value. This is a safer alternative to null values found in other languages.</p>
<h3 id="definition-of-option"><a class="header" href="#definition-of-option">Definition of <code>Option</code>:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-using-option"><a class="header" href="#example-using-option">Example: Using <code>Option</code></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_char(s: &amp;str, c: char) -&gt; Option&lt;usize&gt; {
    for (i, ch) in s.chars().enumerate() {
        if ch == c {
            return Some(i);
        }
    }
    None
}

let position = find_char("hello", 'e');
match position {
    Some(i) =&gt; println!("Found at index: {}", i),
    None =&gt; println!("Character not found."),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-70"><a class="header" href="#explanation-70">Explanation:</a></h3>
<ul>
<li><code>Option&lt;T&gt;</code> can either be <code>Some(T)</code> where <code>T</code> is a value, or <code>None</code> indicating no value.</li>
<li>The <code>find_char</code> function returns <code>Some</code> with the index of the character if found, otherwise <code>None</code>.</li>
</ul>
<h2 id="6-enum-methods"><a class="header" href="#6-enum-methods">6. Enum Methods</a></h2>
<p>You can also define methods on enums using <code>impl</code> blocks, similar to structs. This allows you to encapsulate behavior within the enum itself.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Message {
    fn call(&amp;self) {
        match self {
            Message::Quit =&gt; println!("Quit"),
            Message::Move { x, y } =&gt; println!("Move to x = {}, y = {}", x, y),
            Message::Write(text) =&gt; println!("Write message: {}", text),
            Message::ChangeColor(r, g, b) =&gt; println!("Change color to red = {}, green = {}, blue = {}", r, g, b),
        }
    }
}

// Using the method
let m = Message::Write(String::from("hello"));
m.call();
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-71"><a class="header" href="#explanation-71">Explanation:</a></h3>
<ul>
<li>The <code>call</code> method performs pattern matching internally to handle different variants of the <code>Message</code> enum.</li>
<li>This approach allows you to organize related functionality directly within the enum.</li>
</ul>
<h2 id="7-enum-with-associated-data"><a class="header" href="#7-enum-with-associated-data">7. Enum with Associated Data</a></h2>
<p>Enums can store data directly within each variant. This makes enums versatile and allows them to carry complex information, similar to structs.</p>
<h3 id="example-enums-with-different-data-types"><a class="header" href="#example-enums-with-different-data-types">Example: Enums with Different Data Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));
let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-72"><a class="header" href="#explanation-72">Explanation:</a></h3>
<ul>
<li><code>IpAddr</code> enum can hold either a <code>V4</code> or <code>V6</code> variant, each containing an IP address in the form of a <code>String</code>.</li>
</ul>
<h2 id="8-enum-variants-with-complex-data"><a class="header" href="#8-enum-variants-with-complex-data">8. Enum Variants with Complex Data</a></h2>
<p>Variants can also store complex data structures such as tuples, structs, or other enums.</p>
<h3 id="example-enum-with-structs"><a class="header" href="#example-enum-with-structs">Example: Enum with Structs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    octet1: u8,
    octet2: u8,
    octet3: u8,
    octet4: u8,
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(String),
}

let local = IpAddr::V4(Ipv4Addr {
    octet1: 127,
    octet2: 0,
    octet3: 0,
    octet4: 1,
});
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-73"><a class="header" href="#explanation-73">Explanation:</a></h3>
<ul>
<li>The <code>IpAddr</code> enum's <code>V4</code> variant holds an <code>Ipv4Addr</code> struct, while the <code>V6</code> variant holds a <code>String</code>.</li>
</ul>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>Enums in Rust are a powerful way to define and work with data that can take on different forms. By leveraging Rust's pattern matching and enum features, you can create expressive and maintainable code. Whether you're handling a simple set of states or managing complex data, enums offer the flexibility you need to model your application's behavior effectively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-and-implementing-error-handling-in-rust"><a class="header" href="#understanding-and-implementing-error-handling-in-rust">Understanding and Implementing Error Handling in Rust</a></h1>
<p>Error handling is a critical aspect of software development, ensuring that your program can gracefully handle unexpected situations and continue operating or fail safely. Rust provides a robust error handling system that balances safety and control, allowing you to manage errors effectively without compromising performance or reliability. This tutorial will guide you through the various error handling techniques in Rust, including the <code>Result</code> and <code>Option</code> enums, panic handling, and best practices.</p>
<h2 id="1-introduction-to-error-handling"><a class="header" href="#1-introduction-to-error-handling">1. Introduction to Error Handling</a></h2>
<p>Rust’s approach to error handling revolves around two core concepts:</p>
<ul>
<li><strong>Recoverable Errors</strong>: These errors are expected and can be handled, allowing the program to recover or proceed with alternative logic. Rust uses the <code>Result</code> enum for recoverable errors.</li>
<li><strong>Unrecoverable Errors</strong>: These are serious issues that prevent the program from continuing, and Rust uses the <code>panic!</code> macro to handle them.</li>
</ul>
<h3 id="11-panic-and-unrecoverable-errors"><a class="header" href="#11-panic-and-unrecoverable-errors">1.1 Panic and Unrecoverable Errors</a></h3>
<p>The <code>panic!</code> macro is used to handle unrecoverable errors by terminating the program. It should be used sparingly, primarily when a situation occurs that the program cannot or should not recover from.</p>
<h4 id="example-triggering-a-panic"><a class="header" href="#example-triggering-a-panic">Example: Triggering a Panic</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    panic!("Something went wrong!");
}</code></pre></pre>
<h3 id="explanation-74"><a class="header" href="#explanation-74">Explanation:</a></h3>
<ul>
<li>The program will terminate immediately when <code>panic!</code> is called, and an error message will be printed to the console.</li>
</ul>
<h3 id="12-backtrace"><a class="header" href="#12-backtrace">1.2 Backtrace</a></h3>
<p>When a panic occurs, Rust can generate a backtrace that helps you trace the cause of the panic. To enable backtraces, you set the environment variable <code>RUST_BACKTRACE=1</code> before running the program.</p>
<pre><code class="language-bash">RUST_BACKTRACE=1 cargo run
</code></pre>
<h2 id="2-the-result-enum"><a class="header" href="#2-the-result-enum">2. The <code>Result</code> Enum</a></h2>
<p>For handling recoverable errors, Rust provides the <code>Result</code> enum. <code>Result</code> is a generic enum with two variants:</p>
<ul>
<li><code>Ok(T)</code>: Indicates success and contains a value of type <code>T</code>.</li>
<li><code>Err(E)</code>: Indicates an error and contains a value of type <code>E</code>.</li>
</ul>
<h3 id="syntax-2"><a class="header" href="#syntax-2">Syntax:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="21-using-result-for-error-handling"><a class="header" href="#21-using-result-for-error-handling">2.1 Using <code>Result</code> for Error Handling</a></h3>
<p>When a function can fail, it returns a <code>Result</code>. The caller of the function can then decide how to handle the success or failure.</p>
<h4 id="example-opening-a-file"><a class="header" href="#example-opening-a-file">Example: Opening a File</a></h4>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let file_result = File::open("hello.txt");

    let file = match file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create("hello.txt") {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!("Problem creating the file: {:?}", e),
            },
            other_error =&gt; panic!("Problem opening the file: {:?}", other_error),
        },
    };
}</code></pre></pre>
<h3 id="explanation-75"><a class="header" href="#explanation-75">Explanation:</a></h3>
<ul>
<li><code>File::open</code> returns a <code>Result&lt;File, io::Error&gt;</code>.</li>
<li>The <code>match</code> expression is used to handle both <code>Ok</code> and <code>Err</code> variants.</li>
<li>If the file is not found, the code attempts to create it. If another error occurs, the program panics.</li>
</ul>
<h3 id="22-propagating-errors"><a class="header" href="#22-propagating-errors">2.2 Propagating Errors</a></h3>
<p>Sometimes you want to propagate errors to the calling function instead of handling them immediately. This can be done using the <code>?</code> operator, which simplifies error propagation by returning the error if it occurs.</p>
<h4 id="example-propagating-errors-with-"><a class="header" href="#example-propagating-errors-with-">Example: Propagating Errors with <code>?</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut file = File::open("username.txt")?;
    let mut username = String::new();
    file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-76"><a class="header" href="#explanation-76">Explanation:</a></h3>
<ul>
<li>The <code>?</code> operator is used after <code>File::open</code> and <code>file.read_to_string</code> to propagate errors.</li>
<li>If an error occurs, it is returned to the calling function immediately, simplifying the code.</li>
</ul>
<h2 id="3-the-option-enum"><a class="header" href="#3-the-option-enum">3. The <code>Option</code> Enum</a></h2>
<p>While not specifically an error handling type, the <code>Option</code> enum is often used in situations where a value may or may not be present. It is a way to handle the absence of a value without resorting to nulls, which can lead to unsafe code.</p>
<h3 id="syntax-3"><a class="header" href="#syntax-3">Syntax:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="31-using-option-for-safe-handling-of-none-values"><a class="header" href="#31-using-option-for-safe-handling-of-none-values">3.1 Using <code>Option</code> for Safe Handling of None Values</a></h3>
<p>The <code>Option</code> enum can be used when a function might not return a value, such as when looking up an item in a collection.</p>
<h4 id="example-handling-option"><a class="header" href="#example-handling-option">Example: Handling <code>Option</code></a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_number = Some(5);
    let no_number: Option&lt;i32&gt; = None;

    match some_number {
        Some(num) =&gt; println!("The number is: {}", num),
        None =&gt; println!("No number found."),
    }
}</code></pre></pre>
<h3 id="explanation-77"><a class="header" href="#explanation-77">Explanation:</a></h3>
<ul>
<li><code>some_number</code> contains a value (<code>Some(5)</code>), while <code>no_number</code> is <code>None</code>.</li>
<li>The <code>match</code> expression handles both cases safely.</li>
</ul>
<h2 id="4-custom-error-types"><a class="header" href="#4-custom-error-types">4. Custom Error Types</a></h2>
<p>For more complex programs, you may want to define your own error types. This allows you to create meaningful errors that are specific to your application.</p>
<h3 id="example-defining-a-custom-error-type"><a class="header" href="#example-defining-a-custom-error-type">Example: Defining a Custom Error Type</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

#[derive(Debug)]
enum CustomError {
    NotFound,
    PermissionDenied,
    Other(String),
}

impl fmt::Display for CustomError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            CustomError::NotFound =&gt; write!(f, "Resource not found"),
            CustomError::PermissionDenied =&gt; write!(f, "Permission denied"),
            CustomError::Other(ref err) =&gt; write!(f, "{}", err),
        }
    }
}

fn get_data(id: u32) -&gt; Result&lt;String, CustomError&gt; {
    if id == 0 {
        Err(CustomError::NotFound)
    } else if id == 1 {
        Err(CustomError::PermissionDenied)
    } else {
        Ok(String::from("Data found"))
    }
}

fn main() {
    match get_data(1) {
        Ok(data) =&gt; println!("Success: {}", data),
        Err(e) =&gt; println!("Error: {}", e),
    }
}</code></pre></pre>
<h3 id="explanation-78"><a class="header" href="#explanation-78">Explanation:</a></h3>
<ul>
<li><code>CustomError</code>: An enum representing different kinds of errors.</li>
<li>The <code>fmt::Display</code> trait is implemented to customize the error message format.</li>
<li><code>get_data</code> returns a <code>Result</code> that could either be <code>Ok</code> with a string or an <code>Err</code> with a <code>CustomError</code>.</li>
</ul>
<h2 id="5-best-practices-for-error-handling"><a class="header" href="#5-best-practices-for-error-handling">5. Best Practices for Error Handling</a></h2>
<h3 id="51-prefer-using-result-and-option"><a class="header" href="#51-prefer-using-result-and-option">5.1 Prefer Using <code>Result</code> and <code>Option</code></a></h3>
<p>Use <code>Result</code> for recoverable errors and <code>Option</code> when a value might be absent. These enums make your code more explicit and safer, reducing the chance of bugs.</p>
<h3 id="52-use--for-error-propagation"><a class="header" href="#52-use--for-error-propagation">5.2 Use <code>?</code> for Error Propagation</a></h3>
<p>The <code>?</code> operator is a concise and idiomatic way to propagate errors. It simplifies your code by reducing the need for nested <code>match</code> expressions.</p>
<h3 id="53-avoid-panic-in-production-code"><a class="header" href="#53-avoid-panic-in-production-code">5.3 Avoid Panic in Production Code</a></h3>
<p>While <code>panic!</code> is useful for handling unrecoverable errors during development, it should be avoided in production code where possible. Instead, prefer handling errors gracefully using <code>Result</code> and <code>Option</code>.</p>
<h3 id="54-define-custom-errors-when-needed"><a class="header" href="#54-define-custom-errors-when-needed">5.4 Define Custom Errors When Needed</a></h3>
<p>For larger applications, define custom error types to better capture the nature of the errors in your domain. This improves code clarity and error handling logic.</p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>Error handling in Rust is designed to be both safe and efficient, ensuring that your programs can handle unexpected situations robustly. By using <code>Result</code> for recoverable errors, <code>Option</code> for optional values, and <code>panic!</code> for unrecoverable errors, you can write code that is both reliable and maintainable. Understanding these concepts and applying best practices will help you build resilient Rust applications that handle errors gracefully and effectively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-and-using-collection-types-in-rust"><a class="header" href="#understanding-and-using-collection-types-in-rust">Understanding and Using Collection Types in Rust</a></h1>
<p>Collection types in Rust are powerful tools that allow you to store and manage multiple values efficiently. Rust’s standard library provides several collection types, each designed for different use cases. The most commonly used collections are vectors, strings, hash maps, and sets. This tutorial will guide you through the basics of these collection types, including how to create, manipulate, and use them effectively.</p>
<h2 id="1-introduction-to-collection-types"><a class="header" href="#1-introduction-to-collection-types">1. Introduction to Collection Types</a></h2>
<p>Collections in Rust are data structures that can hold multiple values. Unlike arrays and tuples, collections are generally stored on the heap and can grow or shrink in size dynamically. Rust provides several key collection types:</p>
<ul>
<li><strong>Vectors (<code>Vec&lt;T&gt;</code>)</strong>: A resizable array.</li>
<li><strong>Strings (<code>String</code>)</strong>: A growable string type.</li>
<li><strong>Hash Maps (<code>HashMap&lt;K, V&gt;</code>)</strong>: A key-value store.</li>
<li><strong>Sets (<code>HashSet&lt;T&gt;</code>)</strong>: A collection of unique values.</li>
</ul>
<h3 id="11-ownership-and-borrowing-with-collections"><a class="header" href="#11-ownership-and-borrowing-with-collections">1.1 Ownership and Borrowing with Collections</a></h3>
<p>When working with collections, it's essential to understand Rust's ownership and borrowing rules. Elements within a collection must adhere to Rust's strict ownership principles, ensuring that memory is managed safely.</p>
<h2 id="2-vectors-vect"><a class="header" href="#2-vectors-vect">2. Vectors (<code>Vec&lt;T&gt;</code>)</a></h2>
<p>Vectors are the most commonly used collection type in Rust. They allow you to store a dynamic list of values that can grow and shrink in size.</p>
<h3 id="21-creating-a-vector"><a class="header" href="#21-creating-a-vector">2.1 Creating a Vector</a></h3>
<p>You can create a vector using the <code>vec!</code> macro or by explicitly calling <code>Vec::new()</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Creating a vector using vec! macro
    let mut numbers = vec![1, 2, 3, 4, 5];

    // Creating an empty vector and pushing elements
    let mut more_numbers: Vec&lt;i32&gt; = Vec::new();
    more_numbers.push(6);
    more_numbers.push(7);

    println!("{:?}", numbers);
    println!("{:?}", more_numbers);
}</code></pre></pre>
<h3 id="explanation-79"><a class="header" href="#explanation-79">Explanation:</a></h3>
<ul>
<li><code>vec![1, 2, 3, 4, 5]</code>: Creates a vector with initial elements.</li>
<li><code>Vec::new()</code>: Creates an empty vector to which you can add elements using <code>push()</code>.</li>
</ul>
<h3 id="22-accessing-and-modifying-elements"><a class="header" href="#22-accessing-and-modifying-elements">2.2 Accessing and Modifying Elements</a></h3>
<p>You can access elements in a vector using indexing or the <code>get</code> method. Modifying elements requires a mutable reference.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut numbers = vec![10, 20, 30, 40];

    // Accessing elements
    let first = numbers[0];
    println!("First element: {}", first);

    // Accessing elements with get method
    match numbers.get(2) {
        Some(third) =&gt; println!("Third element: {}", third),
        None =&gt; println!("No third element."),
    }

    // Modifying an element
    numbers[1] = 25;
    println!("Modified numbers: {:?}", numbers);
}</code></pre></pre>
<h3 id="explanation-80"><a class="header" href="#explanation-80">Explanation:</a></h3>
<ul>
<li><code>numbers[0]</code>: Accesses the first element directly.</li>
<li><code>numbers.get(2)</code>: Safely accesses the third element, returning <code>Option&lt;&amp;T&gt;</code>.</li>
</ul>
<h3 id="23-iterating-over-a-vector"><a class="header" href="#23-iterating-over-a-vector">2.3 Iterating Over a Vector</a></h3>
<p>You can iterate over a vector using a <code>for</code> loop or an iterator.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    // Iterating with a for loop
    for number in &amp;numbers {
        println!("Number: {}", number);
    }

    // Iterating with an iterator
    let sum: i32 = numbers.iter().sum();
    println!("Sum: {}", sum);
}</code></pre></pre>
<h3 id="explanation-81"><a class="header" href="#explanation-81">Explanation:</a></h3>
<ul>
<li><code>for number in &amp;numbers</code>: Iterates over references to elements in the vector.</li>
<li><code>numbers.iter()</code>: Creates an iterator to process elements, here used to calculate the sum.</li>
</ul>
<h3 id="24-vector-and-memory-management"><a class="header" href="#24-vector-and-memory-management">2.4 Vector and Memory Management</a></h3>
<p>Vectors automatically handle memory allocation and deallocation, ensuring efficient use of resources. When a vector goes out of scope, its memory is freed.</p>
<h2 id="3-strings-string"><a class="header" href="#3-strings-string">3. Strings (<code>String</code>)</a></h2>
<p>Strings in Rust are a complex data type designed to handle UTF-8 encoded text. The <code>String</code> type is a growable, heap-allocated string.</p>
<h3 id="31-creating-and-manipulating-strings"><a class="header" href="#31-creating-and-manipulating-strings">3.1 Creating and Manipulating Strings</a></h3>
<p>You can create strings from string literals or by using the <code>String::new()</code> function.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from("Hello");

    // Appending to a string
    s.push_str(", world!");

    // Replacing part of a string
    let new_s = s.replace("world", "Rust");

    println!("{}", s);
    println!("{}", new_s);
}</code></pre></pre>
<h3 id="explanation-82"><a class="header" href="#explanation-82">Explanation:</a></h3>
<ul>
<li><code>String::from("Hello")</code>: Creates a <code>String</code> from a string literal.</li>
<li><code>push_str</code>: Appends a string slice to a <code>String</code>.</li>
<li><code>replace</code>: Replaces part of the string with another substring.</li>
</ul>
<h3 id="32-concatenation-and-formatting"><a class="header" href="#32-concatenation-and-formatting">3.2 Concatenation and Formatting</a></h3>
<p>Strings can be concatenated using the <code>+</code> operator or the <code>format!</code> macro.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("Hello");
    let s2 = String::from(", world!");

    // Using the + operator
    let s3 = s1 + &amp;s2;

    // Using format! macro
    let s4 = format!("{}{}", s3, " How are you?");

    println!("{}", s4);
}</code></pre></pre>
<h3 id="explanation-83"><a class="header" href="#explanation-83">Explanation:</a></h3>
<ul>
<li><code>s1 + &amp;s2</code>: Concatenates <code>s1</code> and <code>s2</code>. Note that <code>s1</code> is moved and can no longer be used.</li>
<li><code>format!</code>: Creates a new <code>String</code> by concatenating multiple strings.</li>
</ul>
<h3 id="33-iterating-over-strings"><a class="header" href="#33-iterating-over-strings">3.3 Iterating Over Strings</a></h3>
<p>Strings in Rust can be iterated over by characters or by bytes.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from("hello");

    // Iterating over characters
    for c in s.chars() {
        println!("{}", c);
    }

    // Iterating over bytes
    for b in s.bytes() {
        println!("{}", b);
    }
}</code></pre></pre>
<h3 id="explanation-84"><a class="header" href="#explanation-84">Explanation:</a></h3>
<ul>
<li><code>s.chars()</code>: Iterates over the characters in the string.</li>
<li><code>s.bytes()</code>: Iterates over the bytes of the string.</li>
</ul>
<h2 id="4-hash-maps-hashmapk-v"><a class="header" href="#4-hash-maps-hashmapk-v">4. Hash Maps (<code>HashMap&lt;K, V&gt;</code>)</a></h2>
<p>Hash maps in Rust store key-value pairs and allow for efficient retrieval of values based on keys. They are similar to dictionaries in Python or maps in C++.</p>
<h3 id="41-creating-a-hash-map"><a class="header" href="#41-creating-a-hash-map">4.1 Creating a Hash Map</a></h3>
<p>You can create a hash map using <code>HashMap::new()</code> or by using the <code>collect</code> method on an iterator of tuples.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();

    // Inserting key-value pairs
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Red"), 50);

    // Creating a hash map from tuples
    let teams = vec![String::from("Blue"), String::from("Yellow")];
    let initial_scores = vec![10, 20];
    let scores: HashMap&lt;_, _&gt; = teams.into_iter().zip(initial_scores.into_iter()).collect();

    println!("{:?}", scores);
}</code></pre></pre>
<h3 id="explanation-85"><a class="header" href="#explanation-85">Explanation:</a></h3>
<ul>
<li><code>scores.insert</code>: Adds a key-value pair to the hash map.</li>
<li><code>zip</code>: Combines two iterators into tuples, which are then collected into a hash map.</li>
</ul>
<h3 id="42-accessing-and-modifying-values"><a class="header" href="#42-accessing-and-modifying-values">4.2 Accessing and Modifying Values</a></h3>
<p>You can access values in a hash map using the key, and modify them similarly to vectors.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);

    // Accessing a value
    let score = scores.get(&amp;String::from("Blue"));
    match score {
        Some(&amp;s) =&gt; println!("Score: {}", s),
        None =&gt; println!("No score found."),
    }

    // Modifying a value
    scores.insert(String::from("Blue"), 25);

    // Iterating over key-value pairs
    for (key, value) in &amp;scores {
        println!("{}: {}", key, value);
    }
}</code></pre></pre>
<h3 id="explanation-86"><a class="header" href="#explanation-86">Explanation:</a></h3>
<ul>
<li><code>scores.get</code>: Returns an <code>Option&lt;&amp;V&gt;</code> for the key, which can be handled safely.</li>
<li><code>scores.insert</code>: Replaces the value associated with a key if it already exists.</li>
</ul>
<h3 id="43-hash-map-and-ownership"><a class="header" href="#43-hash-map-and-ownership">4.3 Hash Map and Ownership</a></h3>
<p>Keys and values are owned by the hash map, meaning that ownership is transferred when inserting into the hash map. This affects how you interact with data before and after insertion.</p>
<h2 id="5-sets-hashsett"><a class="header" href="#5-sets-hashsett">5. Sets (<code>HashSet&lt;T&gt;</code>)</a></h2>
<p>A set is a collection of unique values. Rust provides <code>HashSet</code>, which is backed by a hash map for fast membership checking.</p>
<h3 id="51-creating-and-using-a-hash-set"><a class="header" href="#51-creating-and-using-a-hash-set">5.1 Creating and Using a Hash Set</a></h3>
<p>You can create a <code>HashSet</code> using <code>HashSet::new()</code> or from an iterator.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;

fn main() {
    let mut books = HashSet::new();

    // Adding elements to the set
    books.insert("The Rust Programming Language");
    books.insert("Programming Rust");
    books.insert("Rust by Example");

    // Checking for membership
    if books.contains("Programming Rust") {
        println!("We have the book.");
    }

    // Iterating over the set
    for book in &amp;books {
        println!("{}", book);
    }
}</code></pre></pre>
<h3 id="explanation-87"><a class="header" href="#explanation-87">Explanation:</a></h3>
<ul>
<li><code>books.insert</code>: Adds a value to the set. Duplicate values are automatically discarded.</li>
<li><code>books.contains</code>: Checks if a value is in the set.</li>
</ul>
<h2 id="6-summary-1"><a class="header" href="#6-summary-1">6. Summary</a></h2>
<p>In</p>
<p>Rust, collection types such as vectors, strings, hash maps, and sets provide powerful ways to manage and manipulate groups of data. Understanding how to use these collections effectively allows you to write more efficient and flexible Rust programs. By leveraging the strengths of each collection type, you can optimize both performance and memory usage in your applications.</p>
<p>This tutorial covered the basics of creating, accessing, and manipulating these collections, as well as some advanced features such as iterating and handling ownership. As you continue to work with Rust, mastering these collection types will be a crucial step in becoming proficient in the language.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
