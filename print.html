<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_Primitive_Data_Types/index.html"><strong aria-hidden="true">1.</strong> Primitive Data Types</a></li><li class="chapter-item expanded "><a href="02_Compound_Data_Types/index.html"><strong aria-hidden="true">2.</strong> Compound Data Types</a></li><li class="chapter-item expanded "><a href="03_Functions/index.html"><strong aria-hidden="true">3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="04_Ownership/index.html"><strong aria-hidden="true">4.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="05_Borrowing_and_References/index.html"><strong aria-hidden="true">5.</strong> Borrowing and References</a></li><li class="chapter-item expanded "><a href="06_Variables_&_Mutability/index.html"><strong aria-hidden="true">6.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="07_Constants/index.html"><strong aria-hidden="true">7.</strong> Constants</a></li><li class="chapter-item expanded "><a href="08_Shadowing/index.html"><strong aria-hidden="true">8.</strong> Shadowing</a></li><li class="chapter-item expanded "><a href="09_Comments/index.html"><strong aria-hidden="true">9.</strong> Comments</a></li><li class="chapter-item expanded "><a href="10_If_Else_Statements_Control_Flow/index.html"><strong aria-hidden="true">10.</strong> If-else Statements</a></li><li class="chapter-item expanded "><a href="11_Loops-Control-Flow/index.html"><strong aria-hidden="true">11.</strong> Loops</a></li><li class="chapter-item expanded "><a href="12_Structs/index.html"><strong aria-hidden="true">12.</strong> Structs</a></li><li class="chapter-item expanded "><a href="13_Enums/index.html"><strong aria-hidden="true">13.</strong> Enums</a></li><li class="chapter-item expanded "><a href="14_Error-Handling/index.html"><strong aria-hidden="true">14.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="15_Collection-Types/index.html"><strong aria-hidden="true">15.</strong> Collection Types</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="primitive-data-types"><a class="header" href="#primitive-data-types">Primitive Data Types</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Rust is a statically typed programming language, which means the type of each variable must be known at compile time. This ensures type safety and can prevent a wide range of bugs. Rust's primitive data types, also known as scalar types, include integers, floating-point numbers, Booleans, and characters. This lesson covers each of these types in detail, providing examples to illustrate their usage.</p>
<h2 id="integers"><a class="header" href="#integers">Integers</a></h2>
<h3 id="signed-and-unsigned-integers"><a class="header" href="#signed-and-unsigned-integers">Signed and Unsigned Integers</a></h3>
<p>In Rust, integers come in two main varieties: signed and unsigned. Signed integers can represent both positive and negative values, while unsigned integers can only represent positive values. Each variety comes in different sizes, which determine the range of values they can hold.</p>
<h4 id="signed-integers"><a class="header" href="#signed-integers">Signed Integers</a></h4>
<ul>
<li><code>i8</code>: 8-bit signed integer</li>
<li><code>i16</code>: 16-bit signed integer</li>
<li><code>i32</code>: 32-bit signed integer</li>
<li><code>i64</code>: 64-bit signed integer</li>
<li><code>i128</code>: 128-bit signed integer</li>
</ul>
<h4 id="unsigned-integers"><a class="header" href="#unsigned-integers">Unsigned Integers</a></h4>
<ul>
<li><code>u8</code>: 8-bit unsigned integer</li>
<li><code>u16</code>: 16-bit unsigned integer</li>
<li><code>u32</code>: 32-bit unsigned integer</li>
<li><code>u64</code>: 64-bit unsigned integer</li>
<li><code>u128</code>: 128-bit unsigned integer</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32 = 42; // Signed 32-bit integer
    let y: u64 = 100; // Unsigned 64-bit integer
    
    println!("Signed integer: {}", x);
    println!("Unsigned integer: {}", y);
}</code></pre></pre>
<h3 id="range-of-values"><a class="header" href="#range-of-values">Range of Values</a></h3>
<p>The range of values an integer type can hold depends on its size. For example, an <code>i32</code> can hold values from <code>-2^31</code> to <code>2^31 - 1</code>, while a <code>u32</code> can hold values from <code>0</code> to <code>2^32 - 1</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let max_i32: i32 = i32::MAX;
    let max_i64: i64 = i64::MAX;
    
    println!("Maximum value of i32: {}", max_i32);
    println!("Maximum value of i64: {}", max_i64);
}</code></pre></pre>
<h3 id="compiler-errors"><a class="header" href="#compiler-errors">Compiler Errors</a></h3>
<p>If you try to assign a value that is out of range for a given type, the Rust compiler will produce an error.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32 = 2_147_483_648; // This will cause a compile-time error
}</code></pre></pre>
<p>The error message will indicate that the value does not fit within the specified type.</p>
<h2 id="floating-point-numbers"><a class="header" href="#floating-point-numbers">Floating-Point Numbers</a></h2>
<p>Rust provides two types of floating-point numbers: <code>f32</code> and <code>f64</code>. These types represent numbers with fractional parts.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pi: f64 = 3.14;
    
    println!("Value of Pi: {}", pi);
}</code></pre></pre>
<h2 id="boolean-values"><a class="header" href="#boolean-values">Boolean Values</a></h2>
<p>Boolean values in Rust are represented by the <code>bool</code> type. A <code>bool</code> can have one of two values: <code>true</code> or <code>false</code>.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let is_snowing: bool = true;
    
    println!("Is it snowing? {}", is_snowing);
}</code></pre></pre>
<h2 id="characters"><a class="header" href="#characters">Characters</a></h2>
<p>The <code>char</code> type represents a single Unicode scalar value. This includes characters from many languages, as well as special characters.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let letter: char = 'A';
    
    println!("First letter of the alphabet: {}", letter);
}</code></pre></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This lesson covered the basic primitive data types in Rust, including integers, floating-point numbers, Booleans, and characters. Understanding these types is fundamental to writing safe and efficient Rust programs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compound-data-types"><a class="header" href="#compound-data-types">Compound Data Types</a></h1>
<p>In this lesson, we will explore the compound data types in Rust: arrays, tuples, slices, and strings. Each of these types allows for the storage and manipulation of multiple values in a structured way. We will examine the characteristics, usage, and differences between these types, ensuring a comprehensive understanding of each.</p>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>Arrays in Rust are a fixed-size collection of elements of the same type. This means that once an array is declared, its size cannot be changed, and all elements within the array must be of the same type.</p>
<h3 id="declaration-and-initialization"><a class="header" href="#declaration-and-initialization">Declaration and Initialization</a></h3>
<p>Here is an example of how to declare and initialize an array in Rust:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers: [i32; 5] = [1, 2, 3, 4, 5];
    println!("Number array: {:?}", numbers);
}</code></pre></pre>
<p>In this code:</p>
<ul>
<li><code>let numbers: [i32; 5]</code> declares an array named <code>numbers</code> of type <code>i32</code> with a length of 5.</li>
<li>The array is initialized with the values <code>[1, 2, 3, 4, 5]</code>.</li>
<li><code>println!("Number array: {:?}", numbers);</code> prints the array using the debug format specifier <code>:?</code>.</li>
</ul>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p>If you attempt to mix data types in an array, Rust will generate a compilation error:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mix = [1, "Apple", true]; // This line will cause a compilation error
    println!("Mix array: {:?}", mix);
}</code></pre></pre>
<p>The above code will result in the following error:</p>
<pre><code>error[E0308]: mismatched types
expected integer, found `&amp;str`
</code></pre>
<p>This error occurs because Rust arrays must be homogeneous, containing elements of the same type.</p>
<h3 id="accessing-array-elements"><a class="header" href="#accessing-array-elements">Accessing Array Elements</a></h3>
<p>You can access elements of an array using indices:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let fruits: [&amp;str; 3] = ["Apple", "Banana", "Orange"];
    println!("First fruit: {}", fruits[0]);
    println!("Second fruit: {}", fruits[1]);
    println!("Third fruit: {}", fruits[2]);
    println!("Fruit array: {:?}", fruits);
}</code></pre></pre>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>Tuples in Rust are used to group multiple values of different types into a single compound type. Tuples have a fixed size and can contain heterogeneous types.</p>
<h3 id="declaration-and-initialization-1"><a class="header" href="#declaration-and-initialization-1">Declaration and Initialization</a></h3>
<p>Here is an example of declaring and initializing a tuple:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let person: (&amp;str, i32, bool) = ("Alice", 30, false);
    println!("Person tuple: {:?}", person);
}</code></pre></pre>
<p>In this code:</p>
<ul>
<li><code>let person: (&amp;str, i32, bool)</code> declares a tuple named <code>person</code> containing a <code>&amp;str</code>, an <code>i32</code>, and a <code>bool</code>.</li>
<li>The tuple is initialized with the values <code>("Alice", 30, false)</code>.</li>
<li><code>println!("Person tuple: {:?}", person);</code> prints the tuple using the debug format specifier <code>:?</code>.</li>
</ul>
<h3 id="accessing-tuple-elements"><a class="header" href="#accessing-tuple-elements">Accessing Tuple Elements</a></h3>
<p>You can access elements of a tuple using pattern matching or indexing:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let person = ("Alice", 30, false);
    let (name, age, is_student) = person;
    println!("Name: {}", name);
    println!("Age: {}", age);
    println!("Is student: {}", is_student);
    println!("Person tuple: {:?}", person);
}</code></pre></pre>
<p>You can also access elements by index:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let person = ("Alice", 30, false);
    println!("Name: {}", person.0);
    println!("Age: {}", person.1);
    println!("Is student: {}", person.2);
}</code></pre></pre>
<h2 id="slices"><a class="header" href="#slices">Slices</a></h2>
<p>Slices in Rust are dynamically sized views into a contiguous sequence of elements. They do not own the data they reference and can be used to borrow a section of an array.</p>
<h3 id="declaration-and-initialization-2"><a class="header" href="#declaration-and-initialization-2">Declaration and Initialization</a></h3>
<p>Here is an example of declaring and using a slice:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers: [i32; 5] = [1, 2, 3, 4, 5];
    let number_slice: &amp;[i32] = &amp;numbers[1..4];
    println!("Number slice: {:?}", number_slice);
}</code></pre></pre>
<p>In this code:</p>
<ul>
<li><code>let number_slice: &amp;[i32] = &amp;numbers[1..4];</code> creates a slice that references elements from index 1 to 3 of the <code>numbers</code> array.</li>
<li><code>println!("Number slice: {:?}", number_slice);</code> prints the slice.</li>
</ul>
<h2 id="strings-and-string-slices"><a class="header" href="#strings-and-string-slices">Strings and String Slices</a></h2>
<p>Strings in Rust are growable, mutable, and stored on the heap. They are owned types, meaning they manage their memory.</p>
<h3 id="string-declaration-and-initialization"><a class="header" href="#string-declaration-and-initialization">String Declaration and Initialization</a></h3>
<p>Here is an example of declaring and using a <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut greeting = String::from("Hello");
    greeting.push_str(", world!");
    println!("{}", greeting);
}</code></pre></pre>
<p>In this code:</p>
<ul>
<li><code>let mut greeting = String::from("Hello");</code> creates a mutable <code>String</code> initialized with <code>"Hello"</code>.</li>
<li><code>greeting.push_str(", world!");</code> appends <code>", world!"</code> to the <code>greeting</code> string.</li>
<li><code>println!("{}", greeting);</code> prints the resulting string.</li>
</ul>
<h3 id="string-slices"><a class="header" href="#string-slices">String Slices</a></h3>
<p>String slices are references to a portion of a string. They are immutable and usually used for borrowing.</p>
<p>Here is an example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let greeting = String::from("Hello, world!");
    let hello = &amp;greeting[0..5];
    println!("Slice: {}", hello);
}</code></pre></pre>
<p>In this code:</p>
<ul>
<li><code>let hello = &amp;greeting[0..5];</code> creates a string slice referencing the first five characters of <code>greeting</code>.</li>
<li><code>println!("Slice: {}", hello);</code> prints the slice.</li>
</ul>
<h3 id="differences-between-string-and-str"><a class="header" href="#differences-between-string-and-str">Differences between <code>String</code> and <code>&amp;str</code></a></h3>
<ul>
<li><code>String</code> is a growable, mutable, owned type stored on the heap.</li>
<li><code>&amp;str</code> is an immutable reference to a string slice, usually stored on the stack.</li>
</ul>
<p>Here is an example demonstrating these differences:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string = String::from("Hello, world!");
    let string_slice: &amp;str = &amp;string;
    println!("String: {}", string);
    println!("String slice: {}", string_slice);
}</code></pre></pre>
<p>In summary, understanding compound data types in Rust is crucial for efficient memory management and effective programming. Arrays, tuples, slices, and strings each have unique characteristics and uses, allowing for flexible and powerful data handling in Rust applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<h2 id="introduction-to-functions-in-rust"><a class="header" href="#introduction-to-functions-in-rust">Introduction to Functions in Rust</a></h2>
<p>In this lesson, we will delve into the concept of functions in Rust. Until now, you have encountered only one function, the <code>main</code> function. This tutorial will provide a detailed understanding of defining and using functions in Rust, adhering to scientific rigor and addressing potential inaccuracies.</p>
<h3 id="the-main-function"><a class="header" href="#the-main-function">The Main Function</a></h3>
<p>The <code>main</code> function is the entry point of every Rust program. When you navigate to your project's folder and execute <code>cargo run</code>, the <code>main</code> function is invoked. For instance, the following simple program will print "Hello, world!" after compilation:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>If you rename the <code>main</code> function to something else, such as <code>hello</code>, Rust will produce errors because it cannot find the <code>main</code> function:</p>
<ul>
<li><code>function hello is never used</code></li>
<li><code>E0601: main function not found in crate</code></li>
</ul>
<p>The <code>main</code> function must always be present as it serves as the entry point for the program.</p>
<h3 id="defining-functions"><a class="header" href="#defining-functions">Defining Functions</a></h3>
<p>In Rust, any function starts with the keyword <code>fn</code>, followed by the function name, parentheses, and curly braces encompassing the function body. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_function() {
    // function body
}
<span class="boring">}</span></code></pre></pre>
<h4 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h4>
<p>Rust uses snake_case for function and variable names. This means all letters should be lowercase and words are separated by underscores. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello_world() {
    println!("Hello, Rust!");
}
<span class="boring">}</span></code></pre></pre>
<p>Avoid using kebab-case (e.g., <code>hello-world</code>) as it is not permitted in Rust function names.</p>
<h3 id="function-parameters-and-return-values"><a class="header" href="#function-parameters-and-return-values">Function Parameters and Return Values</a></h3>
<p>Functions can accept parameters and return values. Parameters are specified within the parentheses following the function name, and the return type is specified after an arrow (<code>-&gt;</code>).</p>
<h4 id="example-simple-function"><a class="header" href="#example-simple-function">Example: Simple Function</a></h4>
<p>Here is a simple function that prints a message:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello_world() {
    println!("Hello, Rust!");
}
<span class="boring">}</span></code></pre></pre>
<p>To use this function, call it from the <code>main</code> function:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    hello_world();
}</code></pre></pre>
<h4 id="example-function-with-parameters"><a class="header" href="#example-function-with-parameters">Example: Function with Parameters</a></h4>
<p>Functions can accept parameters of various types. Hereâ€™s an example function that takes an integer parameter and prints it:</p>
<pre><pre class="playground"><code class="language-rust">fn print_height(height: i32) {
    println!("My height is {} cm.", height);
}

fn main() {
    print_height(182);
}</code></pre></pre>
<h3 id="function-hoisting"><a class="header" href="#function-hoisting">Function Hoisting</a></h3>
<p>In Rust, you can define functions either before or after the <code>main</code> function. This is known as function hoisting. For example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    greet();
}

fn greet() {
    println!("Hello, Rust!");
}</code></pre></pre>
<h3 id="expressions-and-statements"><a class="header" href="#expressions-and-statements">Expressions and Statements</a></h3>
<p>Understanding expressions and statements is crucial in Rust.</p>
<ul>
<li><strong>Expression:</strong> Anything that returns a value.</li>
<li><strong>Statement:</strong> Anything that does not return a value.</li>
</ul>
<p>For example, the following are expressions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>5
true
3 + 4
<span class="boring">}</span></code></pre></pre>
<p>An <code>if</code> condition is also an expression in Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = if condition { value1 } else { value2 };
<span class="boring">}</span></code></pre></pre>
<h3 id="returning-values-from-functions"><a class="header" href="#returning-values-from-functions">Returning Values from Functions</a></h3>
<p>Functions in Rust can return values using expressions. The return type is specified after the arrow (<code>-&gt;</code>):</p>
<pre><pre class="playground"><code class="language-rust">fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

fn main() {
    let sum = add(4, 6);
    println!("Sum: {}", sum);
}</code></pre></pre>
<h3 id="example-calculating-bmi"><a class="header" href="#example-calculating-bmi">Example: Calculating BMI</a></h3>
<p>Let's create a function that calculates the Body Mass Index (BMI). The formula for BMI is weight in kilograms divided by the square of height in meters.</p>
<pre><pre class="playground"><code class="language-rust">fn calculate_bmi(weight: f64, height: f64) -&gt; f64 {
    weight / (height * height)
}

fn main() {
    let weight = 70.0;
    let height = 1.75;
    let bmi = calculate_bmi(weight, height);
    println!("Your BMI is {:.2}", bmi);
}</code></pre></pre>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>This tutorial has provided a comprehensive overview of functions in Rust. Functions are fundamental building blocks in Rust, allowing you to organize and reuse code effectively. Understanding the correct syntax, naming conventions, and the difference between expressions and statements is essential for writing efficient Rust programs.</p>
<p>By mastering these concepts, you will be better equipped to handle more complex programming challenges in Rust. Continue practicing and exploring the language to deepen your understanding.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>In this lesson, we will delve into the concept of ownership in Rust. Understanding ownership is crucial for managing memory safely and efficiently, a key feature that distinguishes Rust from other programming languages. This tutorial aims to provide a comprehensive understanding of ownership, its rules, and how it addresses common memory management issues.</p>
<h2 id="why-ownership-exists"><a class="header" href="#why-ownership-exists">Why Ownership Exists</a></h2>
<p>Memory management has always been a critical aspect of programming. Languages like C and C++ give developers complete control over memory allocation and deallocation. However, this flexibility can lead to bugs such as double freeing memory or memory leaks when memory is not properly released.</p>
<p>To mitigate these issues, some languages employ garbage collection (GC), which automatically manages memory allocation and deallocation. While GC simplifies memory management, it can introduce performance overhead and pauses during program execution, as the garbage collector periodically stops the program to reclaim unused memory. This can lead to inefficient performance, especially for applications requiring high memory throughput.</p>
<p>Rust addresses these issues through its unique ownership system, ensuring memory safety without the need for a garbage collector.</p>
<h2 id="ownership-in-rust"><a class="header" href="#ownership-in-rust">Ownership in Rust</a></h2>
<p>Ownership is a set of rules that govern how Rust manages memory. The primary goal of ownership is to ensure memory safety and prevent bugs. Ownership rules are enforced at compile time, ensuring that memory errors are caught early in the development process.</p>
<h3 id="the-three-rules-of-ownership"><a class="header" href="#the-three-rules-of-ownership">The Three Rules of Ownership</a></h3>
<ol>
<li><strong>Each value in Rust has a single owner.</strong></li>
<li><strong>There can only be one owner at a time.</strong></li>
<li><strong>When the owner goes out of scope, the value will be dropped.</strong></li>
</ol>
<h3 id="rule-1-each-value-in-rust-has-a-single-owner"><a class="header" href="#rule-1-each-value-in-rust-has-a-single-owner">Rule 1: Each Value in Rust Has a Single Owner</a></h3>
<p>Each value in Rust is owned by a variable. The ownership of the value is unique to that variable. Here is an example to illustrate this rule:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("Rust");
    println!("The value of s1 is: {}", s1);
}</code></pre></pre>
<p>In this example, the string <code>"Rust"</code> is owned by the variable <code>s1</code>.</p>
<h3 id="rule-2-there-can-only-be-one-owner-at-a-time"><a class="header" href="#rule-2-there-can-only-be-one-owner-at-a-time">Rule 2: There Can Only Be One Owner at a Time</a></h3>
<p>Ownership can be transferred from one variable to another. This is called a "move." When a value is moved, the original owner can no longer access the value. Here is an example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("Rust");
    let s2 = s1;
    println!("The value of s2 is: {}", s2);
    // println!("The value of s1 is: {}", s1); // This will cause an error
}</code></pre></pre>
<p>In this example, ownership of the string <code>"Rust"</code> is moved from <code>s1</code> to <code>s2</code>. Attempting to use <code>s1</code> after the move will result in a compile-time error because <code>s1</code> no longer owns the value.</p>
<h3 id="rule-3-when-the-owner-goes-out-of-scope-the-value-will-be-dropped"><a class="header" href="#rule-3-when-the-owner-goes-out-of-scope-the-value-will-be-dropped">Rule 3: When the Owner Goes Out of Scope, the Value Will Be Dropped</a></h3>
<p>When the owner of a value goes out of scope, Rust automatically deallocates the memory associated with that value. Here is an example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let s1 = String::from("Rust");
        println!("The value of s1 is: {}", s1);
    }
    // s1 is no longer accessible here
}</code></pre></pre>
<p>In this example, <code>s1</code> goes out of scope at the end of the inner block, and the memory associated with <code>s1</code> is deallocated.</p>
<h2 id="borrowing-and-references"><a class="header" href="#borrowing-and-references">Borrowing and References</a></h2>
<p>Borrowing allows you to create references to values without taking ownership. This enables safe concurrent access to values without sacrificing memory safety.</p>
<h3 id="mutable-and-immutable-references"><a class="header" href="#mutable-and-immutable-references">Mutable and Immutable References</a></h3>
<p>You can create immutable references using the <code>&amp;</code> operator, and mutable references using the <code>&amp;mut</code> operator. Here is an example:</p>
<pre><pre class="playground"><code class="language-rust">fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}

fn main() {
    let s1 = String::from("Rust");
    let len = calculate_length(&amp;s1);
    println!("The length of '{}' is {}", s1, len);
}</code></pre></pre>
<p>In this example, <code>calculate_length</code> takes an immutable reference to a <code>String</code>, allowing the function to read the value without taking ownership. The ownership of <code>s1</code> remains with the original owner.</p>
<h3 id="example-illustrating-the-three-rules"><a class="header" href="#example-illustrating-the-three-rules">Example Illustrating the Three Rules</a></h3>
<p>Let's summarize the three rules with an example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("Rust");
    let s2 = s1; // s1 is moved to s2
    println!("The value of s2 is: {}", s2);

    let s3 = String::from("Rust");
    let len = calculate_length(&amp;s3); // borrow s3
    println!("The length of '{}' is {}", s3, len); // s3 can still be used

    {
        let s4 = String::from("Scope");
        println!("The value of s4 is: {}", s4);
    } // s4 goes out of scope and is dropped here
}</code></pre></pre>
<p>This example demonstrates ownership transfer, borrowing, and scope-based deallocation.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>Rust's ownership system is a powerful tool for ensuring memory safety and preventing common memory management bugs. By adhering to the three rules of ownership, developers can write efficient, safe, and reliable code. As the White House Office of the National Cyber Director suggests, transitioning to memory-safe languages like Rust is essential for modern software development.</p>
<p>For further details, refer to the <a href="https://doc.rust-lang.org/book/">Rust Book</a> which provides an in-depth explanation of ownership and other Rust features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing--references"><a class="header" href="#borrowing--references">Borrowing &amp; References</a></h1>
<p>This folder contains Rust code files for Borrowing &amp; References.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables--mutability"><a class="header" href="#variables--mutability">Variables &amp; Mutability</a></h1>
<p>This folder contains Rust code files for Variables &amp; Mutability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<p>This folder contains Rust code files for Constants.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h1>
<p>This folder contains Rust code files for Shadowing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>This folder contains Rust code files for Comments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops--control-flow"><a class="header" href="#loops--control-flow">Loops / Control Flow</a></h1>
<p>In this tutorial, we will delve into the essential concept of loops in Rust programming language. Loops are crucial for repeating a block of code multiple times, and Rust offers three types of loops: <code>loop</code>, <code>while</code>, and <code>for</code> loops. We will explore each of these loops, along with practical examples and code snippets.</p>
<p><strong>1. The <code>loop</code> Keyword:</strong>
The <code>loop</code> keyword in Rust instructs the program to execute a block of code repeatedly until explicitly told to stop. It's an unconditional loop, meaning it will continue running indefinitely until instructed otherwise.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    loop {
        println!("Hello, world!");
        // To stop the loop manually, use Ctrl+C
    }
}</code></pre></pre>
<p><strong>2. Returning Values from a Loop:</strong>
One common use case of loops is to retry an operation that might fail, such as checking whether a thread has completed its job. We can also pass the result of the operation out of the loop. The <code>break</code> expression is used to halt the loop execution and return a value.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;
    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2;
        }
    };
    println!("Result: {}", result); // Output: 20
}</code></pre></pre>
<p><strong>3. Loop Labels:</strong>
When dealing with nested loops, where one loop is inside another, loop labels become useful. By default, <code>break</code> and <code>continue</code> statements apply to the innermost loop. We can use loop labels to specify which loop to break or continue.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    'counting_up: loop {
        let mut count = 0;
        println!("Count: {}", count);
        let mut remaining = 10;
        'inner: loop {
            println!("Remaining: {}", remaining);
            if remaining == 9 {
                break 'counting_up;
            }
            count += 1;
            remaining -= 1;
        }
    }
}</code></pre></pre>
<p><strong>4. Conditional Loops with <code>while</code>:</strong>
The <code>while</code> loop runs the loop as long as a condition holds true. It evaluates the condition in each iteration, and when the condition becomes false, the loop stops. We can implement complex behaviors using a combination of <code>loop</code>, <code>if else</code>, and <code>break</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;
    while number != 0 {
        println!("{}", number);
        number -= 1;
    }
    println!("Hey!");
}</code></pre></pre>
<p><strong>5. Looping Through Collections with <code>for</code> Loop:</strong>
The <code>for</code> loop in Rust iterates over each item in a collection. It is commonly used to loop through arrays, vectors, iterators, etc.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let arr = [1, 2, 3, 4, 5, 6];
    for element in arr.iter() {
        println!("{}", element);
    }

    let strings = ["a", "b", "c", "d", "e", "f"];
    for letter in strings.iter() {
        println!("{}", letter);
    }
}</code></pre></pre>
<p><strong>Conclusion:</strong>
In this lesson, we covered the fundamentals of loops in Rust, including the <code>loop</code>, <code>while</code>, and <code>for</code> loops. Loops are powerful constructs for executing code repeatedly, and mastering them is essential for any Rust programmer. Experiment with the provided examples to solidify your understanding, and stay tuned for more lessons. Thank you for learning with us!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadowing-1"><a class="header" href="#shadowing-1">Shadowing</a></h1>
<p>This folder contains Rust code files for Shadowing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-and-implementing-structs-in-rust"><a class="header" href="#understanding-and-implementing-structs-in-rust">Understanding and Implementing Structs in Rust</a></h1>
<p>In this tutorial, we'll delve into the concept of structs in Rust programming language. Structs are fundamental data structures used to encapsulate related data fields. They resemble tuples but with named fields, providing clarity and expressiveness to your code. Let's explore how to define, instantiate, and manipulate structs in Rust.</p>
<h2 id="1-introduction-to-structs"><a class="header" href="#1-introduction-to-structs">1. Introduction to Structs</a></h2>
<p>Structs in Rust are analogous to tuples but offer named fields for better readability and organization. Each field can have a different data type, making structs versatile and powerful.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax:</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StructName {
    field1: Type1,
    field2: Type2,
    // Add more fields as needed
}
<span class="boring">}</span></code></pre></pre>
<h2 id="2-creating-structs"><a class="header" href="#2-creating-structs">2. Creating Structs</a></h2>
<p>Let's create two structs: <code>Book</code> and <code>User</code>, to demonstrate the concept.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define Book struct
struct Book {
    title: String,
    author: String,
    pages: u32,
    available: bool,
}

// Define User struct
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="3-instantiating-structs"><a class="header" href="#3-instantiating-structs">3. Instantiating Structs</a></h2>
<p>You can create instances of structs by providing values for each field.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instantiate a Book struct
let my_book = Book {
    title: String::from("Rust Programming"),
    author: String::from("John Doe"),
    pages: 200,
    available: true,
};

// Instantiate a User struct
let user1 = User {
    active: true,
    username: String::from("example_user"),
    email: String::from("user@example.com"),
    sign_in_count: 1,
};
<span class="boring">}</span></code></pre></pre>
<h2 id="4-accessing-and-modifying-struct-fields"><a class="header" href="#4-accessing-and-modifying-struct-fields">4. Accessing and Modifying Struct Fields</a></h2>
<p>You can access and modify struct fields using dot notation. Remember, the entire struct instance must be mutable to modify any of its fields.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Accessing and modifying struct fields
let mut user2 = User {
    active: false,
    username: String::from("another_user"),
    email: String::from("another@example.com"),
    sign_in_count: 0,
};

// Modify email field
user2.email = String::from("new_email@example.com");
<span class="boring">}</span></code></pre></pre>
<h2 id="5-returning-structs-from-functions"><a class="header" href="#5-returning-structs-from-functions">5. Returning Structs from Functions</a></h2>
<p>Functions can return structs, providing a convenient way to create and initialize structs.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define a function to build a User struct
fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        email, // field init shorthand
        username,
        sign_in_count: 1,
    }
}

// Call the function to create a User struct
let user3 = build_user(String::from("user3@example.com"), String::from("user3"));
<span class="boring">}</span></code></pre></pre>
<h2 id="6-creating-instances-from-other-instances"><a class="header" href="#6-creating-instances-from-other-instances">6. Creating Instances from Other Instances</a></h2>
<p>You can create new instances of a struct by using values from existing instances.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create a new User instance based on user1 but with a different email
let user4 = User {
    email: user1.email, // Reuse email from user1
    ..user1 // Reuse other fields from user1
};
<span class="boring">}</span></code></pre></pre>
<h2 id="7-tuple-structs-and-unit-like-structs"><a class="header" href="#7-tuple-structs-and-unit-like-structs">7. Tuple Structs and Unit-Like Structs</a></h2>
<p>Tuple structs are similar to normal structs but without named fields. Unit-like structs have no fields and are used for implementing traits without storing data.</p>
<h2 id="tuple-struct"><a class="header" href="#tuple-struct">Tuple Struct:</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define a tuple struct
struct Color(i32, i32, i32);

// Instantiate tuple structs
let black = Color(0, 0, 0);
let white = Color(255, 255, 255);
<span class="boring">}</span></code></pre></pre>
<h2 id="unit-like-struct"><a class="header" href="#unit-like-struct">Unit-Like Struct:</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define a unit-like struct
struct AlwaysEqual;

// Instantiate unit-like struct
let always = AlwaysEqual;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
